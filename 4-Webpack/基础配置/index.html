<!DOCTYPE html>
<!--[if lte IE 8 ]>
<html class="ie" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<![endif]-->
<!--[if (gte IE 9)|!(IE)]><!-->
<!--
***************  *      *     *
      8          *    *       *
      8          *  *         *
      8          **           *
      8          *  *         *
      8          *    *       *
      8          *      *     *
      8          *        *   ***********    -----Theme By Kieran(http://go.kieran.top)
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN" lang="zh-CN">
<!--<![endif]-->

<head>
  <title>基本配置 | 一宿更名_BLOG</title>
  <!-- Meta data -->
    <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" >
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="generator" content="一宿更名_BLOG">
    <meta name="author" content="盛祥玉">
    <meta name="description" content="" />
    <meta name="keywords" content="" />

    <!-- Favicon, (keep icon in root folder) -->
    <link rel="Shortcut Icon" href="/img/favicon.ico" type="image/ico">

    <link rel="alternate" href="/atom.xml" title="一宿更名_BLOG" type="application/atom+xml">
    <link rel="stylesheet" href="/css/all.css" media="screen" type="text/css">
    
    <link rel="stylesheet" href="/highlightjs/vs.css" type="text/css">
    

    <!--[if IE 8]>
    <link rel="stylesheet" type="text/css" href="/css/ie8.css" />
    <![endif]-->

    <!-- jQuery | Load our jQuery, with an alternative source fallback to a local version if request is unavailable -->
    <script src="/js/jquery-1.11.1.min.js"></script>
    <script>window.jQuery || document.write('<script src="js/jquery-1.11.1.min.js"><\/script>')</script>

    <!-- Load these in the <head> for quicker IE8+ load times -->
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="/js/html5shiv.min.js"></script>
    <script src="/js/respond.min.js"></script>
    <![endif]-->

  
  
  

  <style>.col-md-8.col-md-offset-2.opening-statement img{display:none;}</style>
</head>

<!--
<body class="post-template">
-->
<body id="index" class="lightnav animsition">

      <!-- ============================ Off-canvas navigation =========================== -->

    <div class="sb-slidebar sb-right sb-style-overlay sb-momentum-scrolling">
        <div class="sb-close" aria-label="Close Menu" aria-hidden="true">
            <img src="/img/close.png" alt="Close"/>
        </div>
        <!-- Lists in Slidebars -->
        <ul class="sb-menu">
            <li><a href="/" class="animsition-link" title="Home">Home</a></li>
            <li><a href="/archives" class="animsition-link" title="archive">archives</a></li>
            <!-- Dropdown Menu -->
			 
            <li>
                <a class="sb-toggle-submenu">Works<span class="sb-caret"></span></a>
                <ul class="sb-submenu">
                    
                        <li><a href="/" target="_BLANK" class="animsition-link">AAA</a></li>
                    
                        <li><a href="/atom.xml" target="_BLANK" class="animsition-link">BBB</a></li>
                    
                </ul>
            </li>
            
            
        	<li>
        		<a class="sb-toggle-submenu">Categories<span class="sb-caret"></span></a>
            	<ul class="sb-submenu">
				  	
				    <li><a href="/categories/1-Css/" class="animsition-link">1-Css<small>(11)</small></a></li>
				    
				    <li><a href="/categories/1-JavaScript/" class="animsition-link">1-JavaScript<small>(14)</small></a></li>
				    
				    <li><a href="/categories/1-TypeScript/" class="animsition-link">1-TypeScript<small>(3)</small></a></li>
				    
				    <li><a href="/categories/2-React/" class="animsition-link">2-React<small>(10)</small></a></li>
				    
				    <li><a href="/categories/2-React-Hooks/" class="animsition-link">2-React_Hooks<small>(5)</small></a></li>
				    
				    <li><a href="/categories/2-Redux和Router/" class="animsition-link">2-Redux和Router<small>(9)</small></a></li>
				    
				    <li><a href="/categories/2-Vue/" class="animsition-link">2-Vue<small>(12)</small></a></li>
				    
				    <li><a href="/categories/3-Brower/" class="animsition-link">3-Brower<small>(30)</small></a></li>
				    
				    <li><a href="/categories/4-Node/" class="animsition-link">4-Node<small>(1)</small></a></li>
				    
				    <li><a href="/categories/4-Promise/" class="animsition-link">4-Promise<small>(7)</small></a></li>
				    
				    <li><a href="/categories/4-Webpack/" class="animsition-link">4-Webpack<small>(8)</small></a></li>
				    
				    <li><a href="/categories/业务和思想/" class="animsition-link">业务和思想<small>(15)</small></a></li>
				    
				    <li><a href="/categories/前端大项/" class="animsition-link">前端大项<small>(9)</small></a></li>
				    
				    <li><a href="/categories/基础补充/" class="animsition-link">基础补充<small>(5)</small></a></li>
				    
				    <li><a href="/categories/框架差异/" class="animsition-link">框架差异<small>(8)</small></a></li>
				    
				    <li><a href="/categories/算法相关/" class="animsition-link">算法相关<small>(10)</small></a></li>
				    
				    <li><a href="/categories/超脱领悟/" class="animsition-link">超脱领悟<small>(9)</small></a></li>
				    
				    <li><a href="/categories/面试复盘/" class="animsition-link">面试复盘<small>(1)</small></a></li>
				    
				</ul>
        	</li>
			
            
            <li>
                <a class="sb-toggle-submenu">Links<span class="sb-caret"></span></a>
                <ul class="sb-submenu">
                    
                    <li><a target="_blank" rel="noopener" href="http://go.kieran.top/" class="animsition-link">Kieran</a></li>
                    
                    <li><a target="_blank" rel="noopener" href="http://domain.com/" class="animsition-link">Name</a></li>
                    
                </ul>
            </li>
            
        </ul>
        <!-- Lists in Slidebars -->
        <ul class="sb-menu secondary">
            
            <li><a href="/about.html" class="animsition-link" title="about">About</a></li>
            <li><a href="/atom.xml" class="animsition-link" title="rss">RSS</a></li>
        </ul>
    </div>
    
    <!-- ============================ END Off-canvas navigation =========================== -->

    <!-- ============================ #sb-site Main Page Wrapper =========================== -->

    <div id="sb-site">
        <!-- #sb-site - All page content should be contained within this id, except the off-canvas navigation itself -->

        <!-- ============================ Header & Logo bar =========================== -->

        <div id="navigation" class="navbar navbar-fixed-top">
            <div class="navbar-inner">
                <div class="container">
                    <!-- Nav logo -->
                    <div class="logo">
                        <a href="/" title="Logo" class="animsition-link">
                         <img src="/img/logo.png" alt="Logo" width="35px;"/> 
                        </a>
                    </div>
                    <!-- // Nav logo -->
                    <!-- Info-bar -->
                    <nav>
                        <ul class="nav">
                            <li><a href="/" class="animsition-link">一宿更名_BLOG</a></li>
                            <li class="nolink"><span>Always </span>Creative.</li>
                            
                            <li><a href="https://github.com/Yxgm" title="Github" target="_blank"><i class="icon-github"></i></a></li>
                            
                            
                            
                            
                            
                            <li class="nolink"><span>Welcome!</span></li>
                        </ul>
                    </nav>
                    <!--// Info-bar -->
                </div>
                <!-- // .container -->
                <div class="learnmore sb-toggle-right">More</div>
                <button type="button" class="navbar-toggle menu-icon sb-toggle-right" title="More">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar before"></span>
                <span class="icon-bar main"></span>
                <span class="icon-bar after"></span>
                </button>
            </div>
            <!-- // .navbar-inner -->
        </div>

        <!-- ============================ Header & Logo bar =========================== -->


      
<section id="intro">
    <div class="container">
        <div class="row col-md-offset-2">
            <div class="col-md-8">
    			<span class="post-meta">
      <time datetime="2022-04-28T02:32:02.441Z" itemprop="datePublished">
          2022-04-28
      </time>
    
    
    | 
    <a href='/tags/webpack/'>webpack</a>
    
    
</span>
                <h1>基本配置</h1>
            </div>
        </div>
        <div class="col-md-8 col-md-offset-2">
      		<h2 id="基本loader和plugin"><a href="#基本loader和plugin" class="headerlink" title="基本loader和plugin"></a>基本loader和plugin</h2><h3 id="1-px2rem-loader-移动端适配"><a href="#1-px2rem-loader-移动端适配" class="headerlink" title="1. px2rem-loader 移动端适配"></a>1. px2rem-loader 移动端适配</h3><p>以前<code>@media screen and.... </code>通过媒体查询匹配不同的机型，需要写多套适配代码。</p>
<p>使用css3 rem单位，，在less-loader中编写px2rem-loader配置，（注意loader的排序，px2rem-loader应该在css-loader之后，sass&#x2F;less-loader之前）</p>
<p>rem是根据根元素来计算大小的，所以说我们应该对不同的机型有不同的根元素的font-size，可以利用手淘的<code>lib-flexible</code>库来处理，可以动态设置根源素的font-size，想要引入<code>lib-flexible</code>的话需要进行资源内联。</p>
<h3 id="2-CSS压缩和单独提取"><a href="#2-CSS压缩和单独提取" class="headerlink" title="2. CSS压缩和单独提取"></a>2. CSS压缩和单独提取</h3><p><code>OptimizeCSSAssetsPlugin</code>插件：压缩（<code>cssMinimizerWebpackPlugin</code>）</p>
<p><code>MiniCssExtractPlugin</code>插件：单独提取文件(ai克斯拽t)</p>
<blockquote>
<p>避免在生产中使用 <code>inline-***</code> 和 <code>eval-***</code>，因为它们会增加 bundle 体积大小，并降低整体性能。</p>
</blockquote>
<p>如果还想在开发环境下启用 CSS 优化，请将 <code>optimization.minimize</code> 设置为 <code>true</code>:</p>
<h3 id="3-html-webpack-plugin"><a href="#3-html-webpack-plugin" class="headerlink" title="3. html-webpack-plugin"></a>3. html-webpack-plugin</h3><p>压缩html并且作为模版，制定chunk入口等等，和<code>add-asset-html-webpack-plugin</code>有版本冲突</p>
<h3 id="4-html-webpack-externals-plugin，cdn引入基础包"><a href="#4-html-webpack-externals-plugin，cdn引入基础包" class="headerlink" title="4. html-webpack-externals-plugin，cdn引入基础包"></a>4. html-webpack-externals-plugin，<span style="color:red">cdn引入基础包</span></h3><p>作用：基础库不打入bundle，作为script标签cdn引入，减少包体积。（不用在模版html中引入react的script标签），在插件中配置cdn的地址和全局变量名。在模版html中将抽离出来的min.js的url作为script引入。</p>
<p>要在plugin中写cdn 地址，script标签使用了crossorigin，会发送重复请求(如果两个script，一个存在crossorigin 一个不存在的话，会请求两次数据)、多个script标签，一个url，且属性相同的时候，一个302（重定向） 一个200</p>
<p>或者直接使用配置externals</p>
<p><code>externals:&#123;react:react &#125;//忽略的库名---npm下载的包名</code></p>
<h3 id="5-raw-loader静态资源内联"><a href="#5-raw-loader静态资源内联" class="headerlink" title="5. raw-loader静态资源内联"></a>5. raw-loader静态资源内联</h3><table>
<thead>
<tr>
<th>优点代码层面</th>
<th>网络请求层面（减少http请求，小图片或者字体内联（url-loader，参数limit））</th>
</tr>
</thead>
<tbody><tr>
<td>1. 页面框架的初始化脚本</td>
<td>1. 内联html: <code>$&#123; require(&#39;raw-loader!./meta.html&#39;)&#125;</code>一般来说，大量的meta信息，在index.html 中内联meta.html</td>
</tr>
<tr>
<td>2. 上报相关打点（css&#x2F;js 初始化&#x2F;加载完成上报服务器等等）</td>
<td>2. 内联js:  <code>&lt;script&gt;&lt;%= require(&#39;raw-loader!babel-loader!./test.js&#39;) %&gt;&lt;/script&gt;</code>如果内联js，有es6语法需要经过babel-loader转化一遍</td>
</tr>
<tr>
<td>3. 将首屏的css内联到index.html中去，不需要二次拉起css文件，避免了页面闪动</td>
<td>3. 内联css： 1. style-loader  2. html-inline-css-webpack-plugin 3 . raw-loader<br/><code>html-inline-css-webpack-plugin</code> 和<code>raw-loader</code>在html加载时候一起存在，而<code>style-loader</code>只有js加载完后才有。</td>
</tr>
</tbody></table>
<blockquote>
<p>样式内联做法：将页面打包过程的产生的所有 CSS 提取成一个独立的文件，然后将这个 CSS 文件内联进 HTML head 里面。这里需要借助 mini-css-extract-plugin 和 html-inline-css-webpack-plugin 来实现 CSS 的内联功能。</p>
<p>先将 css 提取打包成一个独立的 css 文件（使用MiniCssExtractPlugin.loader），然后读取提取出的 css 内容注入到页面的 style 里面去。这个过程在构建阶段完成。同时需要注意：<code> new HtmlInlineCssWebpackPLugin()</code>需要放在插件的最后！</p>
</blockquote>
<h3 id="6-解析图片、字体"><a href="#6-解析图片、字体" class="headerlink" title="6. 解析图片、字体"></a>6. 解析图片、字体</h3><p><code>file-loader</code>:输出的资源存输出目录中，本质也是base64，只不过单独提取出来</p>
<p><code>url-loader </code> :图片转化为base64编码，内嵌于页面之中，有大小限制，如果过大还需要file-loader</p>
<h3 id="7-多入口配置"><a href="#7-多入口配置" class="headerlink" title="7. 多入口配置"></a>7. 多入口配置</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//目的为了不必改webpack.config.js ，我们约定的在src路径下创建多个入口文件夹 （src/.*/js），使用setMPA函数动态生成entry</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">setMPA</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> entry = &#123;&#125;;</span><br><span class="line">  <span class="keyword">const</span> htmlWebpackPlugins = [];</span><br><span class="line">  <span class="keyword">const</span> entryFiles = glob.<span class="title function_">sync</span>(path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;./src/*/index.js&#x27;</span>));  <span class="comment">//取到所有的入口文件的index.js的绝对路径</span></span><br><span class="line"></span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">values</span>(entryPath).<span class="title function_">forEach</span>(<span class="function">(<span class="params">filePath</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> entryName = filePath.<span class="title function_">match</span>(<span class="regexp">/public\/(.*)\/index\.js/</span>)[<span class="number">1</span>]; <span class="comment">//正则获取单个html的文件名</span></span><br><span class="line">    entry[entryName] = filePath;<span class="comment">//合并key-value</span></span><br><span class="line"></span><br><span class="line">    htmlWebpackPlugins.<span class="title function_">push</span>(<span class="comment">//配套相应的模版html</span></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">        <span class="attr">template</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">`src/<span class="subst">$&#123;entryName&#125;</span>/index.html`</span>),</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">`<span class="subst">$&#123;entryName&#125;</span>.html`</span>,</span><br><span class="line">        <span class="attr">chunks</span>: [entryName], <span class="comment">//使用的是哪个chunk。就是哪个入口文件的html,一个html需要对应一个htmlwebpackplugin</span></span><br><span class="line">      &#125;)</span><br><span class="line">    );</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> &#123; entry, htmlWebpackPlugins &#125;;<span class="comment">//最后返回入口对象和插件数组</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="8-生产环境下代码出错，定位到开发环境下的具体错误位置"><a href="#8-生产环境下代码出错，定位到开发环境下的具体错误位置" class="headerlink" title="8. 生产环境下代码出错，定位到开发环境下的具体错误位置"></a>8. 生产环境下代码出错，定位到开发环境下的具体错误位置</h3><p>线上得到报错代码的行和列都是编译后的代码。我们需要提前准备一份生产环境下的map文件（source-map）生成，安装source-map库。</p>
<p>通过<code>new sourceMap.sourceMapConsumer（map.js）</code>构造函数得到consumer，在传入列号和行号，即可获得源代码的准确定位。</p>
<p>基本上开发环境直接用source-map。 production环境就把source-map添加到Error Reporting Tool上。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ea1b27c75f74dd9aef6ee7c6de0e543~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img" style="zoom:40%;" display="inline-block"/><img src="../assets/error.jpg" display="inline-block" width="500"></p>
<p>source-map的json文件都在脚本错误处理平台，我们监控app，一旦出错，try住并且上报，处理平台即可处理，并且展示错误精准位置。</p>
<h3 id="9-scope-hoisting"><a href="#9-scope-hoisting" class="headerlink" title="9. scope hoisting"></a>9. scope hoisting</h3><p>开启条件： production默认开启，使用esm</p>
<p>​        可以简单的把scope hoisting理解为是把每个模块被webpack处理成的模块初始化函数整理到一个统一的包裹函数里，也就是把多个作用域用一个作用域取代，以减少内存消耗并减少包裹块代码，从每个模块有一个包裹函数变成只有一个包裹函数包裹所有的模块，放在了同一个作用域下面，如果有多个变量，会导致命名冲突，会给这些适当的重命名。这样就减少了内存的开销</p>
<p>​        但是有一个前提，当模块的引用次数大于1时，比如被引用了两次或以上，那么这个效果会无效，也就是被引用多次的模块在被webpack处理后，会被独立的包裹函数所包裹</p>
<h3 id="10-splitChunk，代替了CommonChunkPlugin"><a href="#10-splitChunk，代替了CommonChunkPlugin" class="headerlink" title="10. splitChunk，代替了CommonChunkPlugin"></a>10. splitChunk，代替了CommonChunkPlugin</h3><p>​        splitChunk虽然可以做dllplugin的事情，但是更推荐splitChunks去提取页面间的公共js文件（下文所说的Common），因为splitChunks每次去提取基础包还是耗费时间的，如果是dllplugin只需要预编译一次，后面的基础包都可以省略掉。</p>
<p>​        一般来说vendor会单独打一个包，common会单独打一个包。vendor的意思是依赖的第三方库，不会经常变更的，如你代码里的react、react-dom等等，单独打包成vendor的时候也是jsonp的方式。</p>
<p>​        common是指被你重复引用的chunks。可能是vendor，也可能是你自己的某个公共组件，但是大多是vendor的优先级要高 </p>
<h3 id="11-runtingChunk"><a href="#11-runtingChunk" class="headerlink" title="11. runtingChunk"></a>11. runtingChunk</h3><p><code>runtingChunk：&quot;single&quot;</code> 代表模块加载运行的代码，单独分离出来。</p>
<p>​        优化持久化缓存的, runtime 指的是 webpack 的运行环境(具体作用就是模块解析, 加载) 和 模块信息清单, 模块信息清单在每次有模块变更(hash 变更)时都会变更, 所以我们想把这部分代码单独打包出来，配合后端缓存策略，这样就不会因为某个模块的变更导致包含<strong>模块信息的模块</strong>(通常会被包含在最后一个 bundle 中)缓存失效. optimization.runtimeChunk 就是告诉 webpack 是否要把这部分单独打包出来.</p>
<h3 id="12-三种文件输出hash的区别-文件指纹-掘金文章"><a href="#12-三种文件输出hash的区别-文件指纹-掘金文章" class="headerlink" title="12. 三种文件输出hash的区别(文件指纹)掘金文章"></a>12. 三种文件输出hash的区别(文件指纹)<a src="https://juejin.cn/post/6844903942384517127#heading-0">掘金文章</a></h3><table>
<thead>
<tr>
<th>文件后缀hash类型</th>
<th>区别</th>
</tr>
</thead>
<tbody><tr>
<td>hash</td>
<td>hash是根据整个项目构建，只要项目里有文件更改，整个项目构建的hash值都会更改，并且全部文件都共用相同的hash值</td>
</tr>
<tr>
<td>chunkhash</td>
<td>chunkhash根据不同的入口文件(Entry)进行依赖文件解析、构建对应的代码块（chunk），生成对应的哈希值，某文件变化时只有该文件对应代码块（chunk）的hash会变化</td>
</tr>
<tr>
<td>contentHash</td>
<td>每一个代码块（chunk）中的js和css输出文件都会独立生成一个hash，当某一个代码块（chunk）中的js源文件被修改时，只有该代码块（chunk）输出的js文件的hash会发生变化</td>
</tr>
</tbody></table>
<p>为了让文件按需拉取，一般来说css使用contentHash，js文件使用chunkHash（因为js是相互依赖的），图片hash<code>[hash:8]</code>就是代表内容hash </p>
<h3 id="13-动态polyfill"><a href="#13-动态polyfill" class="headerlink" title="13. 动态polyfill"></a>13. 动态polyfill</h3><p>polyfill原理：识别用户的user-agent，下发不同的ployfill，按需引用polyfill，直接使用script官方提供的服务</p>
<p>legacy-peer-deps</p>
<h3 id="14-Source-map-（源代码到构建代码的映射）"><a href="#14-Source-map-（源代码到构建代码的映射）" class="headerlink" title="14. Source-map:（源代码到构建代码的映射）"></a>14. Source-map:（源代码到构建代码的映射）</h3><p>使用了source-map情况下，一个entry，一个chunk，对应两个bundle</p>
<h3 id="15-预加载（等其他文件加载完毕，等浏览器空闲，在加载资源）正常加载（并行加载，同一时间加载多个文件，没有先后顺序）"><a href="#15-预加载（等其他文件加载完毕，等浏览器空闲，在加载资源）正常加载（并行加载，同一时间加载多个文件，没有先后顺序）" class="headerlink" title="15. 预加载（等其他文件加载完毕，等浏览器空闲，在加载资源）正常加载（并行加载，同一时间加载多个文件，没有先后顺序）"></a>15. 预加载（等其他文件加载完毕，等浏览器空闲，在加载资源）正常加载（并行加载，同一时间加载多个文件，没有先后顺序）</h3><p>prefetch： 在文件使用之前会加载文件。<code>webpackPreFetch:true</code>，在用户使用的时候已经加载好了，不会堵塞资源、网络。兼容性差</p>
<h3 id="16-通用构建设计目录"><a href="#16-通用构建设计目录" class="headerlink" title="16. 通用构建设计目录"></a>16. 通用构建设计目录</h3><img src="/Users/yxgm/Documents/知识图鉴/assets/webpack.jpg" width="600">

<h3 id="17-冒烟测试"><a href="#17-冒烟测试" class="headerlink" title="17. 冒烟测试"></a>17. 冒烟测试</h3><p>构建是否成功，每次构建是否有内容输出</p>
<h3 id="18-webpack4的性能优化"><a href="#18-webpack4的性能优化" class="headerlink" title="18. webpack4的性能优化"></a>18. webpack4的性能优化</h3><p>V8 带来的优化(for of 替代 forEach、Map 和 Set 替代 Object、includes 替代 indexOf）</p>
<p>默认使用更快的 md4 hash 算法</p>
<p>webpacks AST 可以直接从 loader 传递给 AST，减少解析时间 </p>
<p>使用字符串方法替代正则表达式</p>
<h3 id="19-web商场的性能优化"><a href="#19-web商场的性能优化" class="headerlink" title="19. web商场的性能优化"></a>19. web商场的性能优化</h3><ol>
<li>渲染优化对一级入口首页，列表页，详情页采用SSR或者Native渲染（RN flutter），对个人中心（固定样式）采用预渲染，没有数据的样子。</li>
<li>弱网优化，使用离线包（将一些html，css等让在客户端的磁盘中去），PWA等离线缓存（Service Work）</li>
<li>webview优化，打开webview的同时并行加载页面数据（webview是原生系统，用于用于移动端 APP 嵌入(Embed) Web 技术，方式是内置了一款高性能webkit内核浏览器。）</li>
</ol>
<h2 id="构建速度优化和缩小构建出来的包体积"><a href="#构建速度优化和缩小构建出来的包体积" class="headerlink" title="构建速度优化和缩小构建出来的包体积"></a>构建速度优化和缩小构建出来的包体积</h2><ol>
<li>先分析打包速度：<code>speed-measure-webpack-plugin</code> 测量你的 webpack 构建期间各个阶段花费的时间</li>
</ol>
<h3 id="1-缓存提升二次构建速度"><a href="#1-缓存提升二次构建速度" class="headerlink" title="1. 缓存提升二次构建速度"></a>1. 缓存提升二次构建速度</h3><ol>
<li><p>babel-loader 不能因为一个js文件变化，导致所有的js文件全部再转一次，所以就要开启babel缓存 <code>cacheDirectory: true </code>，或者rc文件中使用 <code>@babel/plugin-transform-runtime</code>插件</p>
</li>
<li><p>cache-loader模块提供中间缓存，二次构建速度大幅度提升</p>
</li>
<li><p>HardSourceWebpackPlugin：二次构建缓存，第一次构建将花费正常的时间，第二次构建将显着加快（大概提升90%的构建速度）。</p>
<blockquote>
<p>对于上面的三种中间缓存的loader，一定意义上webpack冷启动会变满，因为启动也是有一定的开销的。</p>
</blockquote>
</li>
<li><p>terser-webpack-plugin 压缩缓存 <code>cache：true</code>  </p>
</li>
<li><p>ThreadLoader多进程打包，webpack4默认就开启了多进程（资源独立）打包和缓存</p>
<blockquote>
<p>对于上面的两种方法，当项目较小时，多进程打包反而会使打包速度变慢。</p>
</blockquote>
</li>
</ol>
<h3 id="2-分包Dll，预编译资源模块（Dll-plugin），提升二次构建"><a href="#2-分包Dll，预编译资源模块（Dll-plugin），提升二次构建" class="headerlink" title="2. 分包Dll，预编译资源模块（Dll-plugin），提升二次构建"></a>2. 分包Dll，预编译资源模块（Dll-plugin），提升二次构建</h3><p>​    使用html-webpack-externals-plugin会很多的基础包在index.html script引入过多问题。所以出现一种dllPlugin分包，对一些我们常用但构建时间又长的的包（react，react-dom等等）缓存在dll中，在后续的构建中，直接跳过我们dll的部分，缩短构建时间。配合AddAssetHtmlPlugin使用。</p>
<p>​    但是如今webpack4以上，<a target="_blank" rel="noopener" href="https://www.1024sou.com/article/289012.html">你应该不在需要dll了</a>，Webpack 4+ 以上可用 <a target="_blank" rel="noopener" href="https://tsejx.github.io/webpack-guidebook/best-practice/optimization/precompile#hardsourcewebpackplugin">HardSourceWebpackPlugin</a> 插件代替。</p>
<p>​    从实际前端工程中来说， dll 还是很有必要掌握的。对于一个团队而言，基本是采用相同的技术栈，通常的做法都是把公共框架打成一个 common bundle 文件供所有项目使用。dll 可以很好的满足这种场景：将多个npm包打成一个公共包。因此团队里面的分包方案使用 dll 还是很有价值，常见的会从整个工程的角度分为基础包（react、redux–vendors）、业务公共包（所有业务都要用到的监控上报脚本、页面初始化脚本）、某个业务的js。</p>
<h3 id="3-多进程、多实例打包（提升冷启动速度）"><a href="#3-多进程、多实例打包（提升冷启动速度）" class="headerlink" title="3. 多进程、多实例打包（提升冷启动速度）"></a>3. 多进程、多实例打包（提升冷启动速度）</h3><ol>
<li><p>构建并行：thread-loader 原理：每次 webpack 解析一个模块，会将它及它的依赖分配给 worker 线程中，IPC通信。</p>
</li>
<li><p>压缩并行：terser-webpack-plugin 使用 terser 压缩 JS 的 Webpack 插件。开启 parallel 参数，使用多进程并行运行来提高构建速度。默认并发运行数：os.cpus().length - 1 支持压缩es6语法，配置开启 parallel 参数。替代了以前的uglify.js，webpack4已经内置。</p>
</li>
</ol>
<h3 id="4-缩小构建目标（提升冷启动速度，和后续构建速度）"><a href="#4-缩小构建目标（提升冷启动速度，和后续构建速度）" class="headerlink" title="4. 缩小构建目标（提升冷启动速度，和后续构建速度）"></a>4. 缩小构建目标（提升冷启动速度，和后续构建速度）</h3><p>让webpack减少文件查找的时间，避免不必要的查找，提高命中率。</p>
<h6 id="1-优化-loader-配置"><a href="#1-优化-loader-配置" class="headerlink" title="1. 优化 loader 配置"></a>1. 优化 loader 配置</h6><p>使用 Loader 时可以通过 <code>test</code> 、 <code>include</code> 、 <code>exclude</code> 三个配置项来命中 Loader 要应用规则的文件</p>
<h6 id="2-优化-resolve-module-配置"><a href="#2-优化-resolve-module-配置" class="headerlink" title="2. 优化 resolve.module 配置"></a>2. 优化 resolve.module 配置</h6><p><code>resolve.modules</code> 用于配置 webpack 去哪些目录下寻找第三方模块，<code>resolve.modules</code> 的默认值是 <code>[&#39;node_modules&#39;]</code> ，含义是先去当前目录下的 <code>./node_modules</code> 目录下去找想找的模块，如果没找到就去上一级目录 <code>../node_modules</code> 中找，再没有就去 <code>../../node_modules</code> 中找，以此类推。</p>
<h6 id="3-优化-resolve-alias-配置"><a href="#3-优化-resolve-alias-配置" class="headerlink" title="3. 优化 resolve.alias 配置"></a>3. 优化 resolve.alias 配置</h6><p>通过别名来把原导入路径映射成一个新的导入路径，减少耗时的递归解析操作。</p>
<h6 id="4-优化-resolve-extensions-配置（-js）"><a href="#4-优化-resolve-extensions-配置（-js）" class="headerlink" title="4. 优化 resolve.extensions 配置（.js）"></a>4. 优化 resolve.extensions 配置（.js）</h6><p>在导入语句没带文件后缀时，webpack 会根据 resolve.extension 自动带上后缀后去尝试询问文件是否存在，所以在配置 <code>resolve.extensions</code> 应尽可能注意以下几点：</p>
<ul>
<li><code>resolve.extensions</code> 列表要尽可能的小，不要把项目中不可能存在的情况写到后缀尝试列表中。</li>
<li>频率出现最高的文件后缀要优先放在最前面，以做到尽快的退出寻找过程。</li>
<li>在源码中写导入语句时，要尽可能的带上后缀，从而可以避免寻找过程。</li>
</ul>
<h6 id="5-优化-resolve-mainFields-配置"><a href="#5-优化-resolve-mainFields-配置" class="headerlink" title="5. 优化 resolve.mainFields 配置"></a>5. 优化 resolve.mainFields 配置</h6><p>有一些第三方模块会针对不同环境提供几分代码。 例如分别提供采用 ES5 和 ES6 的2份代码，这2份代码的位置写在 <code>package.json</code> 文件里，如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;jsnext:main&quot;</span><span class="punctuation">:</span> <span class="string">&quot;es/index.js&quot;</span><span class="punctuation">,</span><span class="comment">// 采用 ES6 语法的代码入口文件</span></span><br><span class="line">  <span class="attr">&quot;main&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lib/index.js&quot;</span> <span class="comment">// 采用 ES5 语法的代码入口文件</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>webpack 会根据 <code>mainFields</code> 的配置去决定优先采用那份代码，<code>mainFields</code> 默认如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mainFields</span>: [<span class="string">&#x27;browser&#x27;</span>, <span class="string">&#x27;main&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>webpack 会按照数组里的顺序去 <code>package.json</code> 文件里寻找，只会使用找到的第一个。</p>
<p>假如你想优先采用 ES6 的那份代码，可以这样配置：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mainFields</span>: [<span class="string">&#x27;jsnext:main&#x27;</span>, <span class="string">&#x27;browser&#x27;</span>, <span class="string">&#x27;main&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h6 id="6-优化-module-noParse-配置"><a href="#6-优化-module-noParse-配置" class="headerlink" title="6. 优化 module.noParse 配置"></a>6. 优化 module.noParse 配置</h6><p><code>module.noParse</code> 配置项可以让 Webpack 忽略对部分没采用模块化的文件的递归解析处理，这样做的好处是能提高构建性能。 原因是一些库，例如 jQuery 、ChartJS， 它们庞大又没有采用模块化标准，让 Webpack 去解析这些文件耗时又没有意义。</p>
<h3 id="5-Tree-shaking-（ast-esmoudle-静态编译在编译的时候就确定模块之间的关系）"><a href="#5-Tree-shaking-（ast-esmoudle-静态编译在编译的时候就确定模块之间的关系）" class="headerlink" title="5. Tree shaking （ast+esmoudle+静态编译在编译的时候就确定模块之间的关系）"></a>5. Tree shaking （ast+esmoudle+静态编译在编译的时候就确定模块之间的关系）</h3><ol>
<li><p>js摇树</p>
<p> 一个模块中可能有多个方法，只要是某个方法用到了，整个文件都会打入到bundle中，treeShaking只是将用到的方法，打入bundle，没用到的方法在uglify阶段擦除</p>
</li>
</ol>
<p>​    开启条件：1. 两使用esmodule（cmj方式不支持）    2. 开启production mode   3. 函数不用该有副作用（否则会失效）</p>
<p>​    原理：DCE（Elimination）含义：代码不会执行，不可达到、代码执行结果不会用到、代码只会影响死变量（只写不读），对于如此的代码，我们需要擦除。</p>
<p>​    <span style="color:red">利用es6模块特点（静态引入）：Es6的模块依赖关系是确定的，和运行时的状态无关，对模块代码进行可靠的静态分析，在编译时就确定所用模块具体方法等等，在没有用到的代码处增加注释，在uglify阶段擦除。 而commonjs没有这个可能，requires需要执行才可之后引用了什么模块。tree-shaking 的删除过程类似于js 的垃圾收集：分析 -&gt; 标记 -&gt; 清除，而做这些工作的就是ast的死区分析</span></p>
<p>​    比如说我们开发时候使用解构赋值写import 组件库，webpack会将这句话拆开，变成多语句，分别找到引入组件对应的文件，没有优化前source指向的是element-ui，优化后执行了element-ui&#x2F;form如此对应路径。完成了摇树优化。</p>
<p>​    Webpack 中，Tree-shaking 的实现一是先<strong>标记</strong>出模块导出值中哪些没有被用过，二是使用 Terser 删掉这些没被用到的导出语句。标记过程大致可划分为三个步骤：Make 阶段，收集模块导出变量并记录到模块依赖关系图 ModuleGraph 变量中，Seal 阶段，遍历 ModuleGraph 标记模块导出变量有没有被使用，生成产物时，若变量没有被其它模块使用则删除对应的导出语句</p>
<p>​    问题：对于一个有副作用的模块，全部import，tree-sharking达不到效果，js的动态灵活让静态分析比较困难，同时sideEffect广泛存在。所以说tree-sharking对顶层的纯函数效果优化更好，也是我们编写纯函数的原因之一。</p>
<ol start="2">
<li><p>css摇树</p>
<p> <code>&quot;purgecss-webpack-plugin&quot;: &quot;^1.5.0&quot;</code> ，擦除没有使用到的css类名</p>
</li>
</ol>
<p>参考链接及tree sharking最佳实践：<a target="_blank" rel="noopener" href="https://juejin.cn/post/7002410645316436004">https://juejin.cn/post/7002410645316436004</a></p>
<p>性能提升webpack：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904071736852487">https://juejin.cn/post/6844904071736852487</a></p>

            <div class="clearfix"></div>
            <hr class="nogutter">
        </div>
        <nav class="m-pagination col-md-8 col-md-offset-2 col-sm-24" role="pagination">
    
    <a class="pull-left" href="/1-JavaScript/%E8%87%AA%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0/" style="float: left;">
        ← 自执行函数
    </a>
    
    
    <a class="pull-right" href="/2-React/%E7%89%88%E6%9C%AC%E5%B7%AE%E5%BC%82/">
        react版本差异 →
    </a>
    
</nav>

        <div class="col-md-8 col-md-offset-2 col-sm-24"><script type="text/javascript">
  /**
   * 搜狐畅言
   */

  /*
  document.write('<div id="SOHUCS" sid="' + window.location.pathname.slice(1) + '" ></div>');

  window.onload = function () {
    (function () {
      var appid = 'cytXXXX';
      var conf = 'prod_xxxxxxxxxxxxxxxxx';
      var width = window.innerWidth || document.documentElement.clientWidth;
      var loadJs = function (d, a, id) {
        var c = document.getElementsByTagName("head")[0] || document.head || document.documentElement;
        var b = document.createElement("script");
        b.setAttribute("type", "text/javascript");
        b.setAttribute("charset", "UTF-8");
        b.setAttribute("src", d);
        if (id) {
          b.setAttribute("id", id);
        }
        if (typeof a === "function") {
          if (window.attachEvent) {
            b.onreadystatechange = function () {
              var e = b.readyState;
              if (e === "loaded" || e === "complete") {
                b.onreadystatechange = null;
                a()
              }
            }
          } else {
            b.onload = a
          }
        }
        c.appendChild(b)
      };

      loadJs("https://changyan.sohu.com/upload/changyan.js", function () {
        window.changyan.api.config({
          appid: appid,
          conf: conf
        })
      });
    })();
  }
  */

</script>
</div>
    </div>
</section>


      
<!-- ============================ Footer =========================== -->

<footer>
    <div class="container">
            <div class="copy">
                <p>
                    &copy; 2014<script>new Date().getFullYear()>2010&&document.write("-"+new Date().getFullYear());</script>, Content By 盛祥玉. All Rights Reserved.
                </p>
                <p>Theme By <a target="_blank" rel="noopener" href="//go.kieran.top" style="color: #767D84">Kieran</a></p>
            </div>
            <div class="social">
                <ul>
                    
                    <li><a href="https://github.com/Yxgm" title="Github" target="_blank"><i class="icon-github"></i></a>&nbsp;</li>
                    
                    
                    
                    
                    
                </ul>
            </div>
            <div class="clearfix"> </div>
        </div>
</footer>

<!-- ============================ END Footer =========================== -->
      <!-- Load our scripts -->
<!-- Resizable 'on-demand' full-height hero -->
<script type="text/javascript">
    var resizeHero = function () {
        var hero = $(".cover,.heightblock"),
            window1 = $(window);
        hero.css({
            "height": window1.height()
        });
    };

    resizeHero();

    $(window).resize(function () {
        resizeHero();
    });
</script>
<script src="/js/plugins.min.js"></script><!-- Bootstrap core and concatenated plugins always load here -->
<script src="/js/scripts.js"></script><!-- Theme scripts -->


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$('#intro').find('img').each(function(){
  var alt = this.alt;

  if (alt){
    $(this).after('<span class="caption" style="display:none">' + alt + '</span>');
  }

  $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="gallery" />');
});
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



      
</body>
</html>
