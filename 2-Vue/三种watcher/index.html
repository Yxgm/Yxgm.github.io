<!DOCTYPE html>
<!--[if lte IE 8 ]>
<html class="ie" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<![endif]-->
<!--[if (gte IE 9)|!(IE)]><!-->
<!--
***************  *      *     *
      8          *    *       *
      8          *  *         *
      8          **           *
      8          *  *         *
      8          *    *       *
      8          *      *     *
      8          *        *   ***********    -----Theme By Kieran(http://go.kieran.top)
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN" lang="zh-CN">
<!--<![endif]-->

<head>
  <title>3种watcher | 一宿更名_BLOG</title>
  <!-- Meta data -->
    <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" >
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="generator" content="一宿更名_BLOG">
    <meta name="author" content="盛祥玉">
    <meta name="description" content="" />
    <meta name="keywords" content="" />

    <!-- Favicon, (keep icon in root folder) -->
    <link rel="Shortcut Icon" href="/img/favicon.ico" type="image/ico">

    <link rel="alternate" href="/atom.xml" title="一宿更名_BLOG" type="application/atom+xml">
    <link rel="stylesheet" href="/css/all.css" media="screen" type="text/css">
    
    <link rel="stylesheet" href="/highlightjs/vs.css" type="text/css">
    

    <!--[if IE 8]>
    <link rel="stylesheet" type="text/css" href="/css/ie8.css" />
    <![endif]-->

    <!-- jQuery | Load our jQuery, with an alternative source fallback to a local version if request is unavailable -->
    <script src="/js/jquery-1.11.1.min.js"></script>
    <script>window.jQuery || document.write('<script src="js/jquery-1.11.1.min.js"><\/script>')</script>

    <!-- Load these in the <head> for quicker IE8+ load times -->
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="/js/html5shiv.min.js"></script>
    <script src="/js/respond.min.js"></script>
    <![endif]-->

  
  
  

  <style>.col-md-8.col-md-offset-2.opening-statement img{display:none;}</style>
</head>

<!--
<body class="post-template">
-->
<body id="index" class="lightnav animsition">

      <!-- ============================ Off-canvas navigation =========================== -->

    <div class="sb-slidebar sb-right sb-style-overlay sb-momentum-scrolling">
        <div class="sb-close" aria-label="Close Menu" aria-hidden="true">
            <img src="/img/close.png" alt="Close"/>
        </div>
        <!-- Lists in Slidebars -->
        <ul class="sb-menu">
            <li><a href="/" class="animsition-link" title="Home">Home</a></li>
            <li><a href="/archives" class="animsition-link" title="archive">archives</a></li>
            <!-- Dropdown Menu -->
			 
            <li>
                <a class="sb-toggle-submenu">Works<span class="sb-caret"></span></a>
                <ul class="sb-submenu">
                    
                        <li><a href="/" target="_BLANK" class="animsition-link">AAA</a></li>
                    
                        <li><a href="/atom.xml" target="_BLANK" class="animsition-link">BBB</a></li>
                    
                </ul>
            </li>
            
            
        	<li>
        		<a class="sb-toggle-submenu">Categories<span class="sb-caret"></span></a>
            	<ul class="sb-submenu">
				  	
				    <li><a href="/categories/1-Css/" class="animsition-link">1-Css<small>(11)</small></a></li>
				    
				    <li><a href="/categories/1-JavaScript/" class="animsition-link">1-JavaScript<small>(14)</small></a></li>
				    
				    <li><a href="/categories/1-TypeScript/" class="animsition-link">1-TypeScript<small>(3)</small></a></li>
				    
				    <li><a href="/categories/2-React/" class="animsition-link">2-React<small>(10)</small></a></li>
				    
				    <li><a href="/categories/2-React-Hooks/" class="animsition-link">2-React_Hooks<small>(5)</small></a></li>
				    
				    <li><a href="/categories/2-Redux和Router/" class="animsition-link">2-Redux和Router<small>(9)</small></a></li>
				    
				    <li><a href="/categories/2-Vue/" class="animsition-link">2-Vue<small>(12)</small></a></li>
				    
				    <li><a href="/categories/3-Brower/" class="animsition-link">3-Brower<small>(30)</small></a></li>
				    
				    <li><a href="/categories/4-Node/" class="animsition-link">4-Node<small>(1)</small></a></li>
				    
				    <li><a href="/categories/4-Promise/" class="animsition-link">4-Promise<small>(7)</small></a></li>
				    
				    <li><a href="/categories/4-Webpack/" class="animsition-link">4-Webpack<small>(8)</small></a></li>
				    
				    <li><a href="/categories/业务和思想/" class="animsition-link">业务和思想<small>(15)</small></a></li>
				    
				    <li><a href="/categories/前端大项/" class="animsition-link">前端大项<small>(9)</small></a></li>
				    
				    <li><a href="/categories/基础补充/" class="animsition-link">基础补充<small>(5)</small></a></li>
				    
				    <li><a href="/categories/框架差异/" class="animsition-link">框架差异<small>(8)</small></a></li>
				    
				    <li><a href="/categories/算法相关/" class="animsition-link">算法相关<small>(10)</small></a></li>
				    
				    <li><a href="/categories/超脱领悟/" class="animsition-link">超脱领悟<small>(9)</small></a></li>
				    
				    <li><a href="/categories/面试复盘/" class="animsition-link">面试复盘<small>(1)</small></a></li>
				    
				</ul>
        	</li>
			
            
            <li>
                <a class="sb-toggle-submenu">Links<span class="sb-caret"></span></a>
                <ul class="sb-submenu">
                    
                    <li><a target="_blank" rel="noopener" href="http://go.kieran.top/" class="animsition-link">Kieran</a></li>
                    
                    <li><a target="_blank" rel="noopener" href="http://domain.com/" class="animsition-link">Name</a></li>
                    
                </ul>
            </li>
            
        </ul>
        <!-- Lists in Slidebars -->
        <ul class="sb-menu secondary">
            
            <li><a href="/about.html" class="animsition-link" title="about">About</a></li>
            <li><a href="/atom.xml" class="animsition-link" title="rss">RSS</a></li>
        </ul>
    </div>
    
    <!-- ============================ END Off-canvas navigation =========================== -->

    <!-- ============================ #sb-site Main Page Wrapper =========================== -->

    <div id="sb-site">
        <!-- #sb-site - All page content should be contained within this id, except the off-canvas navigation itself -->

        <!-- ============================ Header & Logo bar =========================== -->

        <div id="navigation" class="navbar navbar-fixed-top">
            <div class="navbar-inner">
                <div class="container">
                    <!-- Nav logo -->
                    <div class="logo">
                        <a href="/" title="Logo" class="animsition-link">
                         <img src="/img/logo.png" alt="Logo" width="35px;"/> 
                        </a>
                    </div>
                    <!-- // Nav logo -->
                    <!-- Info-bar -->
                    <nav>
                        <ul class="nav">
                            <li><a href="/" class="animsition-link">一宿更名_BLOG</a></li>
                            <li class="nolink"><span>Always </span>Creative.</li>
                            
                            <li><a href="https://github.com/Yxgm" title="Github" target="_blank"><i class="icon-github"></i></a></li>
                            
                            
                            
                            
                            
                            <li class="nolink"><span>Welcome!</span></li>
                        </ul>
                    </nav>
                    <!--// Info-bar -->
                </div>
                <!-- // .container -->
                <div class="learnmore sb-toggle-right">More</div>
                <button type="button" class="navbar-toggle menu-icon sb-toggle-right" title="More">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar before"></span>
                <span class="icon-bar main"></span>
                <span class="icon-bar after"></span>
                </button>
            </div>
            <!-- // .navbar-inner -->
        </div>

        <!-- ============================ Header & Logo bar =========================== -->


      
<section id="intro">
    <div class="container">
        <div class="row col-md-offset-2">
            <div class="col-md-8">
    			<span class="post-meta">
      <time datetime="2022-02-11T02:37:06.000Z" itemprop="datePublished">
          2022-02-11
      </time>
    
    
    | 
    <a href='/tags/vue/'>vue</a>,
    
    <a href='/tags/响应式原理/'>响应式原理</a>
    
    
</span>
                <h1>3种watcher</h1>
            </div>
        </div>
        <div class="col-md-8 col-md-offset-2">
      		<h1 id="八股部分"><a href="#八股部分" class="headerlink" title="八股部分"></a>八股部分</h1><p>methods 一般用于封装一些较为复杂的处理逻辑（同步、异步）</p>
<p>computed 一般用于封装一些简单的同步逻辑，将经过处理的数据返回，然后显示在模版中，以减轻模版的重量</p>
<p>watch 一般用于当需要在数据变化时执行异步或开销较大的操作</p>
<p>method：可以触发响应式，但是没有缓存，也就是说在template中执行一次，就会发生一次计算。</p>
<h2 id="computed：computed擅长处理的场景：一个数据受多个数据影响"><a href="#computed：computed擅长处理的场景：一个数据受多个数据影响" class="headerlink" title="computed：computed擅长处理的场景：一个数据受多个数据影响"></a>computed：computed擅长处理的场景：一个数据受多个数据影响</h2><p>1、支持缓存，只有依赖数据发生改变，才会重新进行计算，在template中有使用，就会先执行。</p>
<p>2、不支持异步，当computed内有异步操作时无效，无法监听数据的变化，因为computed本来就是用来返回计算后的值得，是需要马上得到的，而不是要等一段时间才能得到的</p>
<p>3、computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值</p>
<p>4、如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed</p>
<p>5、如果computed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。</p>
<p>6、计算属性的函数不接受参数</p>
<h2 id="watch：watch擅长处理的场景：一个数据影响多个数据"><a href="#watch：watch擅长处理的场景：一个数据影响多个数据" class="headerlink" title="watch：watch擅长处理的场景：一个数据影响多个数据"></a>watch：watch擅长处理的场景：一个数据影响多个数据</h2><p>1、不支持缓存，当数据变，才会触发相应的操作；并不是立刻执行。</p>
<p>2、watch支持异步，可以监听路由发生改变。</p>
<p>3、监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；</p>
<p>4、当一个属性发生变化时，需要执行对应的操作；一对多；</p>
<p>5.当需要在数据变化时执行异步或开销较大的操作时，只能采用watch。</p>
<p>6、监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数： </p>
<p>immediate：组件加载立即触发回调函数执行，　</p>
<p>deep: 深度监听，为了发现对象内部值的变化，复杂类型的数据时使用，例如数组中的对象内容的改变，注意监听数组的变动不需要这么做。注意：deep无法监听到数组的变动和对象的新增，参考vue数组变异,只有以响应式的方式触发才会被监听到。</p>
<p>7.watch的监听只能是单个的监听，每次监听只能监听一个变量的修改，不能同时监听多个变量的修改，计算属性computed可以依赖多个数据的变化（并且只跟他所依赖的项进行关联）</p>
<h2 id="watch源码的工作流程"><a href="#watch源码的工作流程" class="headerlink" title="watch源码的工作流程"></a>watch源码的工作流程</h2><p>1.初始化组件上配置的watcher属性</p>
<p>2.对watcher属性可能的写法进行规整，得出key和handle</p>
<p>3.通过new Watcher 来创建一个基于key和handle的观察者</p>
<p>4.Watcher 的key为响应式的vm 上的变量，在watcher.get的时候，watcher订阅了对应key的变化。完成响应依赖。</p>
<p>5.当key的值发生了变化，触发watcher的更新方法，并执行回调函数handle</p>
<h2 id="computed源码的流程"><a href="#computed源码的流程" class="headerlink" title="computed源码的流程"></a>computed源码的流程</h2><p>1.初始化的时候会获取computed里的定义。</p>
<p>2.通过遍历第一步的结果，按照computed新的变量名生成Watcher实例。</p>
<p>3.computed的watcher默认是lazy模式的，所以new Watcher 的时候不会调用watcher实例的get方法</p>
<p>4.vue 为computed 里的每个key 代理了一个新的get方法createComputedGetter()，当render页面的时候，新的get调用computed watcher实例的默认get方法。</p>
<p>5.computed执行自定义get方法的时候，会判断是否依赖又变动，没有的话，直接取值，否则去执行获取依赖的变量。</p>
<p>6.获取依赖变量的时候，将computed的watcher实例订阅到依赖的变量的Dep里。</p>
<p>7.走完这一步后，再调用计算列的watcher.depend将组件的watcher实例也订阅到计算列依赖的所有变量的dep中。</p>
<p>8.这样，当变量变化后，会通知computed的watcher将dirty设置为true， 以及组件的watcher更新dom。</p>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>1.watcher 初始化是不执行的，如果想初始化就执行的话可以配置immediate属性</p>
<p>2.一般情况不要直接修改computed的值，会报错，一般通过为computed属性自定义set方法，通过改变依赖变量来改变computed的值</p>
<p>3.computed的属性如果不加入在dom中渲染是不会被加入到响应系统的。所以如果只是数据的变动的监控，不映射到dom上，请使用watcher或者其他方法。</p>
<p>4.watcher和computed 属性定义的函数不能使用箭头函数，否则内部this会指向组件的父环境，比如window，导致调用失败。</p>
<h1 id="源码部分"><a href="#源码部分" class="headerlink" title="源码部分"></a>源码部分</h1><p>Vue.js是采用数据劫持结合发布订阅者模式的方式，通过Object.defineProperty（）来劫持各子属性的setter，gettter，当数据访问时，也就是触发了getter方法，在调度中心中，我们把该数据的副作用收集起来（也就是订阅者在调度中心订阅），之后一旦数据改变时，触发setter方法，对应的dep对象调用notify函数，把所有的副作用函数都在执行一遍，从新渲染视图，就相当于调度中心发布消息给订阅者，触发响应的监听来渲染视图。</p>
<h2 id="首先需要了解的几个对象"><a href="#首先需要了解的几个对象" class="headerlink" title="首先需要了解的几个对象"></a>首先需要了解的几个对象</h2><ol>
<li><p><code>Observer</code>: 这里的主要工作是递归地监听对象上的所有属性，在属性值改变的时候，触发相应的<code>Watcher</code>。我称它为<code>watcher Manager</code></p>
</li>
<li><p><code>Watcher</code>: 观察者，当监听的数据值修改时，执行响应的回调函数，在<code>Vue</code>里面的更新模板内容。</p>
</li>
<li><p><code>Dep</code>: 链接<code>Observer</code>和<code>Watcher</code>的桥梁，每一个<code>Observer</code>对应一个<code>Dep</code>，它内部维护一个数组，保存与该<code>Observer</code>相关的<code>Watcher</code>。<code>Dep.target</code>关健属性</p>
</li>
</ol>
<p><code>dep</code>和<code>watcher</code>有双向绑定的关系:</p>
<blockquote>
<p><code>render watcher</code>中有所有响应式数据的<code>dep</code>对象；</p>
<p>而数据对应的<code>dep</code>对象中，<code>sub</code>数组中有<code>render watcher</code>，还可能有<code>computed watcher</code></p>
</blockquote>
<h2 id="两个核心概念和一个关键属性"><a href="#两个核心概念和一个关键属性" class="headerlink" title="两个核心概念和一个关键属性"></a>两个核心概念和一个关键属性</h2><ol>
<li><p>依赖收集：读取数据时（<code>get</code>操作），将依赖自身的watcher函数（<strong>感觉说成副作用函数会更好理解</strong>）收集到自己dep中，同时 <code>watcher </code>也会保存所有 <code>watcher</code> 依赖数据</p>
<p>🤫：在我看来，依赖收集，是依赖自己把自己收集起来，new Watcher的时候 触发函数执行或者读值，然后把被数据当作副作用函数收集到自己dep中</p>
</li>
<li><p>派发更新：设置数据时（<code>set</code>操作），将自身的副作用函数（dep上的subs数组）全部重新执行一遍，更新vdom数据，patch算出最小修改范围、修改真实dom</p>
</li>
<li><p>currentWatcher：当前的watch函数，唯一变量，是单例的思想体现，为了保证当前的watch唯一，并且顺利推入到依赖回调队列中</p>
</li>
</ol>
<blockquote>
<p>所以：我们要确定一个变量是怎么收集依赖和派发更新</p>
</blockquote>
<h2 id="render-Watcher"><a href="#render-Watcher" class="headerlink" title="render Watcher"></a>render Watcher</h2><p>函数意义：<code>render watcher</code> 即是<code>vnode._update(vm._render())</code>，组件重新构成vdom，patch，挂载</p>
<p>初始化：</p>
<blockquote>
<p><code>initData</code>调用了observe函数，并且新建observe对象，挂载data对象的<code>__ob__</code>属性上，<code>Observer</code> 是 &#96;&#96;data <code> 的观察者，实例上的</code>data<code>属性，添加一个</code><strong>ob</strong><code>属性，代表该</code>data<code>已经被</code>observe&#96;监听。这个是为data服务的</p>
</blockquote>
<p>副作用函数收集阶段：（依赖收集）</p>
<p>一顿初始化完毕后执行  <code>new Watcher(vm, vm.$options.render, () =&gt; &#123;&#125;, true)</code></p>
<blockquote>
<p><code>render</code>函数执行，读取数据，在 new Watch阶段就触发render函数，在render中，又将watcher收集。</p>
<p><code>all</code>的数据getter操作收集依赖</p>
</blockquote>
<h2 id="user-Watcher"><a href="#user-Watcher" class="headerlink" title="user Watcher"></a>user Watcher</h2><p>函数意义：相当于自定义的watcher，监听目标改变时，触发回调（user watcher）</p>
<p>副作用函数收集阶段：（依赖收集）：</p>
<blockquote>
<ol>
<li>先走<code>$watch</code>，后到 <code>new watch</code>目的是配置watcher，初始化watcher， user属性设置为true；</li>
<li><code>user watcher</code>的<code>option</code>选项只有<code>user</code>为<code>true</code>，<code>new Watch</code>之后，会走<code>this.get()</code>，将  **c位给user <code>Watcher</code>**，接着执行 this.getter.call(vm, vm) ，对 vm 的属性进行层级访问, 触发 data 中目标属性的 get 方法, 触发属性对应的 <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue/blob/2.6/src/core/observer/dep.js#L31">dep.depend</a> 方法, 进行依赖收集</li>
<li>在我们写完了watch监听，相当于vue主动的get了一下监听的属性</li>
<li>⚠️：<strong>这里<code>user watcher</code>与众不同的是这里是读值，而不是函数调用</strong></li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> watcher = <span class="keyword">new</span> <span class="title class_">Watcher</span>(vm, expOrFn, cb, options) </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">value</span> = <span class="variable language_">this</span>.<span class="property">lazy</span></span><br><span class="line">      ? <span class="literal">undefined</span></span><br><span class="line">      : <span class="variable language_">this</span>.<span class="title function_">get</span>() <span class="comment">//user watcher 走后者</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get () &#123;</span><br><span class="line">    <span class="title function_">pushTarget</span>(<span class="variable language_">this</span>)<span class="comment">//几种watcher轮着占c位</span></span><br><span class="line">    <span class="keyword">let</span> value</span><br><span class="line">    <span class="keyword">const</span> vm = <span class="variable language_">this</span>.<span class="property">vm</span></span><br><span class="line">    value = <span class="variable language_">this</span>.<span class="property">getter</span>.<span class="title function_">call</span>(vm, vm)</span><br><span class="line">    <span class="comment">//调用对应cb，user watcher是遍历读值，另外两种执行函数</span></span><br><span class="line">    <span class="title function_">popTarget</span>()</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>　<code>user Watcher</code>就会被当前属性收集到自己的<code>dep</code>中，</li>
</ol>
</blockquote>
<p>派发更新：监听属性发生改变时，user watcher执行，</p>
<p>其他的配置项：</p>
<ol>
<li>immediate：immediate判断，为true的话，invokeWithErrorHandling执行，也就是cb直接执行一遍</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (options.<span class="property">immediate</span>) &#123;</span><br><span class="line">  <span class="title function_">pushTarget</span>()</span><br><span class="line">  <span class="title function_">invokeWithErrorHandling</span>(cb, vm, [watcher.<span class="property">value</span>], vm, info)</span><br><span class="line">  <span class="title function_">popTarget</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>deep :true</p>
<p>watch 中设置深层监听, 会执行 <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue/blob/edf7df0c837557dd3ea8d7b42ad8d4b21858ade0/src/core/observer/traverse.js#L14">traverse</a> 对 value 进行深度访问，触发所有属性的 get 方法，实现依赖收集,，效果和 <code>parsePath函数 </code>一致（parsePath会返回下面的循环读值函数）</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> segments = path.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; segments.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj) <span class="keyword">return</span></span><br><span class="line">    obj = obj[segments[i]]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="computed-Watcher"><a href="#computed-Watcher" class="headerlink" title="computed Watcher"></a>computed Watcher</h2><p>函数意义：计算属性是基于数据的响应式依赖进行缓存的，只在相关响应式依赖发生改变时它们才会重新求值，也就是说只要计算属性依赖的数据还没有发生改变，多次访问计算属性会立即返回之前的计算结果，而不必再次执行函数</p>
<p>设计初衷就是为了惰性求值。比如说有一个1000的数组。。。。我们第一次已经遍历过一次了，再次使用，依赖数据没有发生变化，就不必再遍历一遍了。</p>
<h4 id="初始化："><a href="#初始化：" class="headerlink" title="初始化："></a>初始化：</h4><ol>
<li>new Watcher的时候计算属性的fn放入getter，初始化watcher的时候，并没有主动出发属性的get操作，即没有收集依赖。但标记上了lazy标识位，dirty标识位</li>
<li>之后定义vm上读取computed的get操作，初始化完毕</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> watchers = vm.<span class="property">_computedWatchers</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>)</span><br><span class="line">watchers[key] = <span class="keyword">new</span> <span class="title class_">Watcher</span>( </span><br><span class="line">        vm,</span><br><span class="line">        getter || noop,       <span class="comment">//计算属性的fn放入getter</span></span><br><span class="line">        noop,</span><br><span class="line">        computedWatcherOptions<span class="comment">//&#123;lazy:true&#125;</span></span><br><span class="line">      )</span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">value</span> = <span class="variable language_">this</span>.<span class="property">lazy</span>? <span class="attr">undefined</span>: <span class="variable language_">this</span>.<span class="title function_">get</span>()  <span class="comment">//computed watcher 走前者，也就是说没有主动触发get，lazy：标记为懒watcher</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(vm, key, &#123;  <span class="comment">//在vm上挂载computed的key，并且设置computed的get和set</span></span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">get</span>:  <span class="keyword">function</span> <span class="title function_">computedGetter</span> () &#123;            <span class="comment">//computed的get方法</span></span><br><span class="line">   				  <span class="keyword">if</span> (watcher.<span class="property">dirty</span>) watcher.evaluate() <span class="comment">//dirty属性标记意义</span></span><br><span class="line">      			<span class="keyword">if</span> (<span class="title class_">Dep</span>.<span class="property">target</span>) watcher.<span class="title function_">depend</span>()</span><br><span class="line">  			    <span class="keyword">return</span> watcher.<span class="property">value</span>                 <span class="comment">//return fn()结果</span></span><br><span class="line">  &#125;，</span><br><span class="line">    <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125; <span class="comment">// 暂不考虑set情况</span></span><br><span class="line">  &#125;)                </span><br></pre></td></tr></table></figure>

<h4 id="副作用函数收集阶段（依赖收集）："><a href="#副作用函数收集阶段（依赖收集）：" class="headerlink" title="副作用函数收集阶段（依赖收集）："></a>副作用函数收集阶段（依赖收集）：</h4><ol>
<li><p>在首次挂载的时候，初始化了render watcher， 之后调用了this.get()方法，先render watcher 进入c位，在执行vm.update(vm.render)，再vm.render执行</p>
</li>
<li><p>render过程中，读取到了计算属性，触发get，即下面函数，会拿到我们之前初始化的computed watcher，这步很关键，后续要把它推入c位</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">const</span> watcher = <span class="variable language_">this</span>.<span class="property">_computedWatchers</span>[key]</span><br><span class="line"><span class="comment">//取到我们之前初始化的computed watcher，这个watcher上有computed对应的fn</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>首先会判断dirty标识位，第一次进入的时候为true，直接执行<code>watcher.evaluate()</code>,就又去执行watcher的this.get()，<strong>computed watcher进入c位，此时的全局watcher中已经有两个watcher（computed，render）</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">watcher.evaluate()等价于下面</span><br><span class="line">  <span class="comment">//1. this.value = this.get()</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  get () &#123;</span></span><br><span class="line">  <span class="comment">//  pushTarget(this) //把当前的watcher置于c位</span></span><br><span class="line">  <span class="comment">//  const vm = this.vm</span></span><br><span class="line">  <span class="comment">//  let value = this.getter.call(vm, vm)//调用updateComponent或者conputed函数</span></span><br><span class="line">  <span class="comment">//  popTarget()</span></span><br><span class="line">  <span class="comment">//  return value</span></span><br><span class="line">	<span class="comment">//  &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//2. this.dirty = false</span></span><br><span class="line">  <span class="comment">//这一步走完，就代表所有的computed函数中的数据，都已经将computed watcher收集到自己的dep中了。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>执行计算函数，同时内部触发数据的get操作，内部的数据收集computed watcher，这一步走完，就代表所有的computed函数中的数据，都已经将computed watcher收集到内部属性的dep中。</p>
</li>
<li><p>接着执行 watcher.depend() ，判断当前targetStack中是否还有watcher（因为render watcher还在队列之中），将渲染watcher 添加到属性的dep中，computed watcher已经出栈，并且把target的指向改为前一个watcher，现在render watcher 在c位</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">watcher.<span class="title function_">depend</span>()</span><br><span class="line"><span class="comment">//   depend () &#123;</span></span><br><span class="line"><span class="comment">//		let i = this.deps.length</span></span><br><span class="line"><span class="comment">//    while (i--) &#123;</span></span><br><span class="line"><span class="comment">//    this.deps[i].depend()</span></span><br><span class="line"><span class="comment">//  &#125; 所有computed watcher的依赖数据的subs都添加上render watcher</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>此步目的就是计算函数内部数据<strong>不仅要把computed watcher 收集起来，还需要把render watcher收集起来</strong></p>
</li>
</ol>
<p>dirty:意义：再次读取到computed的时候，进入判断，因为dirty在第一次读的时候，设置为false，所以直接返回value</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">get</span>:  <span class="keyword">function</span> <span class="title function_">computedGetter</span> () &#123;            <span class="comment">//computed的get方法</span></span><br><span class="line">			  <span class="keyword">if</span> (watcher.<span class="property">dirty</span>) watcher.evaluate() <span class="comment">//dirty属性标记意义</span></span><br><span class="line">  			<span class="keyword">if</span> (<span class="title class_">Dep</span>.<span class="property">target</span>) watcher.<span class="title function_">depend</span>()</span><br><span class="line">		    <span class="keyword">return</span> watcher.<span class="property">value</span>                 <span class="comment">//return 计算fn()结果</span></span><br></pre></td></tr></table></figure>

<p>计算属性内部数据如果发生更新：会把<code>this.dirty</code> 设置成 <code>true</code>，如果数据变化的时候再执行<code>watcher.evaluate()</code>进行<code>info</code>更新，没有变化的的话<code>this.dirty</code> 就是<code>false</code>，不会执行<code>info</code>方法。这就是computed缓存机制。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局的watcher数组</span></span><br><span class="line"><span class="keyword">const</span> targetStack = []</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">pushTarget</span> (<span class="attr">target</span>: ?<span class="title class_">Watcher</span>) &#123;</span><br><span class="line">  targetStack.<span class="title function_">push</span>(target)</span><br><span class="line">  <span class="title class_">Dep</span>.<span class="property">target</span> = target</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">popTarget</span> () &#123;</span><br><span class="line">  targetStack.<span class="title function_">pop</span>()</span><br><span class="line">  <span class="title class_">Dep</span>.<span class="property">target</span> = targetStack[targetStack.<span class="property">length</span> - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


            <div class="clearfix"></div>
            <hr class="nogutter">
        </div>
        <nav class="m-pagination col-md-8 col-md-offset-2 col-sm-24" role="pagination">
    
    <a class="pull-left" href="/2-Vue/vue%E9%AB%98%E7%BA%A7%E5%92%8C%E7%BB%86%E8%8A%82/" style="float: left;">
        ← vue高级用法和细节
    </a>
    
    
    <a class="pull-right" href="/2-Vue/%E6%A0%B8%E5%BF%83%E5%BA%93/">
        核心库 →
    </a>
    
</nav>

        <div class="col-md-8 col-md-offset-2 col-sm-24"><script type="text/javascript">
  /**
   * 搜狐畅言
   */

  /*
  document.write('<div id="SOHUCS" sid="' + window.location.pathname.slice(1) + '" ></div>');

  window.onload = function () {
    (function () {
      var appid = 'cytXXXX';
      var conf = 'prod_xxxxxxxxxxxxxxxxx';
      var width = window.innerWidth || document.documentElement.clientWidth;
      var loadJs = function (d, a, id) {
        var c = document.getElementsByTagName("head")[0] || document.head || document.documentElement;
        var b = document.createElement("script");
        b.setAttribute("type", "text/javascript");
        b.setAttribute("charset", "UTF-8");
        b.setAttribute("src", d);
        if (id) {
          b.setAttribute("id", id);
        }
        if (typeof a === "function") {
          if (window.attachEvent) {
            b.onreadystatechange = function () {
              var e = b.readyState;
              if (e === "loaded" || e === "complete") {
                b.onreadystatechange = null;
                a()
              }
            }
          } else {
            b.onload = a
          }
        }
        c.appendChild(b)
      };

      loadJs("https://changyan.sohu.com/upload/changyan.js", function () {
        window.changyan.api.config({
          appid: appid,
          conf: conf
        })
      });
    })();
  }
  */

</script>
</div>
    </div>
</section>


      
<!-- ============================ Footer =========================== -->

<footer>
    <div class="container">
            <div class="copy">
                <p>
                    &copy; 2014<script>new Date().getFullYear()>2010&&document.write("-"+new Date().getFullYear());</script>, Content By 盛祥玉. All Rights Reserved.
                </p>
                <p>Theme By <a target="_blank" rel="noopener" href="//go.kieran.top" style="color: #767D84">Kieran</a></p>
            </div>
            <div class="social">
                <ul>
                    
                    <li><a href="https://github.com/Yxgm" title="Github" target="_blank"><i class="icon-github"></i></a>&nbsp;</li>
                    
                    
                    
                    
                    
                </ul>
            </div>
            <div class="clearfix"> </div>
        </div>
</footer>

<!-- ============================ END Footer =========================== -->
      <!-- Load our scripts -->
<!-- Resizable 'on-demand' full-height hero -->
<script type="text/javascript">
    var resizeHero = function () {
        var hero = $(".cover,.heightblock"),
            window1 = $(window);
        hero.css({
            "height": window1.height()
        });
    };

    resizeHero();

    $(window).resize(function () {
        resizeHero();
    });
</script>
<script src="/js/plugins.min.js"></script><!-- Bootstrap core and concatenated plugins always load here -->
<script src="/js/scripts.js"></script><!-- Theme scripts -->


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$('#intro').find('img').each(function(){
  var alt = this.alt;

  if (alt){
    $(this).after('<span class="caption" style="display:none">' + alt + '</span>');
  }

  $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="gallery" />');
});
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



      
</body>
</html>
