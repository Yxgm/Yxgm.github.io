<!DOCTYPE html>
<!--[if lte IE 8 ]>
<html class="ie" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<![endif]-->
<!--[if (gte IE 9)|!(IE)]><!-->
<!--
***************  *      *     *
      8          *    *       *
      8          *  *         *
      8          **           *
      8          *  *         *
      8          *    *       *
      8          *      *     *
      8          *        *   ***********    -----Theme By Kieran(http://go.kieran.top)
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN" lang="zh-CN">
<!--<![endif]-->

<head>
  <title>实习难点总结 | 一宿更名_BLOG</title>
  <!-- Meta data -->
    <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" >
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="generator" content="一宿更名_BLOG">
    <meta name="author" content="盛祥玉">
    <meta name="description" content="" />
    <meta name="keywords" content="" />

    <!-- Favicon, (keep icon in root folder) -->
    <link rel="Shortcut Icon" href="/img/favicon.ico" type="image/ico">

    <link rel="alternate" href="/atom.xml" title="一宿更名_BLOG" type="application/atom+xml">
    <link rel="stylesheet" href="/css/all.css" media="screen" type="text/css">
    
    <link rel="stylesheet" href="/highlightjs/vs.css" type="text/css">
    

    <!--[if IE 8]>
    <link rel="stylesheet" type="text/css" href="/css/ie8.css" />
    <![endif]-->

    <!-- jQuery | Load our jQuery, with an alternative source fallback to a local version if request is unavailable -->
    <script src="/js/jquery-1.11.1.min.js"></script>
    <script>window.jQuery || document.write('<script src="js/jquery-1.11.1.min.js"><\/script>')</script>

    <!-- Load these in the <head> for quicker IE8+ load times -->
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="/js/html5shiv.min.js"></script>
    <script src="/js/respond.min.js"></script>
    <![endif]-->

  
  
  

  <style>.col-md-8.col-md-offset-2.opening-statement img{display:none;}</style>
</head>

<!--
<body class="post-template">
-->
<body id="index" class="lightnav animsition">

      <!-- ============================ Off-canvas navigation =========================== -->

    <div class="sb-slidebar sb-right sb-style-overlay sb-momentum-scrolling">
        <div class="sb-close" aria-label="Close Menu" aria-hidden="true">
            <img src="/img/close.png" alt="Close"/>
        </div>
        <!-- Lists in Slidebars -->
        <ul class="sb-menu">
            <li><a href="/" class="animsition-link" title="Home">Home</a></li>
            <li><a href="/archives" class="animsition-link" title="archive">archives</a></li>
            <!-- Dropdown Menu -->
			 
            <li>
                <a class="sb-toggle-submenu">Works<span class="sb-caret"></span></a>
                <ul class="sb-submenu">
                    
                        <li><a href="/" target="_BLANK" class="animsition-link">AAA</a></li>
                    
                        <li><a href="/atom.xml" target="_BLANK" class="animsition-link">BBB</a></li>
                    
                </ul>
            </li>
            
            
        	<li>
        		<a class="sb-toggle-submenu">Categories<span class="sb-caret"></span></a>
            	<ul class="sb-submenu">
				  	
				    <li><a href="/categories/1-Css/" class="animsition-link">1-Css<small>(11)</small></a></li>
				    
				    <li><a href="/categories/1-JavaScript/" class="animsition-link">1-JavaScript<small>(14)</small></a></li>
				    
				    <li><a href="/categories/1-TypeScript/" class="animsition-link">1-TypeScript<small>(3)</small></a></li>
				    
				    <li><a href="/categories/2-React/" class="animsition-link">2-React<small>(10)</small></a></li>
				    
				    <li><a href="/categories/2-React-Hooks/" class="animsition-link">2-React_Hooks<small>(5)</small></a></li>
				    
				    <li><a href="/categories/2-Redux和Router/" class="animsition-link">2-Redux和Router<small>(9)</small></a></li>
				    
				    <li><a href="/categories/2-Vue/" class="animsition-link">2-Vue<small>(12)</small></a></li>
				    
				    <li><a href="/categories/3-Brower/" class="animsition-link">3-Brower<small>(30)</small></a></li>
				    
				    <li><a href="/categories/4-Node/" class="animsition-link">4-Node<small>(1)</small></a></li>
				    
				    <li><a href="/categories/4-Promise/" class="animsition-link">4-Promise<small>(7)</small></a></li>
				    
				    <li><a href="/categories/4-Webpack/" class="animsition-link">4-Webpack<small>(8)</small></a></li>
				    
				    <li><a href="/categories/业务和思想/" class="animsition-link">业务和思想<small>(15)</small></a></li>
				    
				    <li><a href="/categories/前端大项/" class="animsition-link">前端大项<small>(9)</small></a></li>
				    
				    <li><a href="/categories/基础补充/" class="animsition-link">基础补充<small>(5)</small></a></li>
				    
				    <li><a href="/categories/框架差异/" class="animsition-link">框架差异<small>(8)</small></a></li>
				    
				    <li><a href="/categories/算法相关/" class="animsition-link">算法相关<small>(10)</small></a></li>
				    
				    <li><a href="/categories/超脱领悟/" class="animsition-link">超脱领悟<small>(9)</small></a></li>
				    
				    <li><a href="/categories/面试复盘/" class="animsition-link">面试复盘<small>(1)</small></a></li>
				    
				</ul>
        	</li>
			
            
            <li>
                <a class="sb-toggle-submenu">Links<span class="sb-caret"></span></a>
                <ul class="sb-submenu">
                    
                    <li><a target="_blank" rel="noopener" href="http://go.kieran.top/" class="animsition-link">Kieran</a></li>
                    
                    <li><a target="_blank" rel="noopener" href="http://domain.com/" class="animsition-link">Name</a></li>
                    
                </ul>
            </li>
            
        </ul>
        <!-- Lists in Slidebars -->
        <ul class="sb-menu secondary">
            
            <li><a href="/about.html" class="animsition-link" title="about">About</a></li>
            <li><a href="/atom.xml" class="animsition-link" title="rss">RSS</a></li>
        </ul>
    </div>
    
    <!-- ============================ END Off-canvas navigation =========================== -->

    <!-- ============================ #sb-site Main Page Wrapper =========================== -->

    <div id="sb-site">
        <!-- #sb-site - All page content should be contained within this id, except the off-canvas navigation itself -->

        <!-- ============================ Header & Logo bar =========================== -->

        <div id="navigation" class="navbar navbar-fixed-top">
            <div class="navbar-inner">
                <div class="container">
                    <!-- Nav logo -->
                    <div class="logo">
                        <a href="/" title="Logo" class="animsition-link">
                         <img src="/img/logo.png" alt="Logo" width="35px;"/> 
                        </a>
                    </div>
                    <!-- // Nav logo -->
                    <!-- Info-bar -->
                    <nav>
                        <ul class="nav">
                            <li><a href="/" class="animsition-link">一宿更名_BLOG</a></li>
                            <li class="nolink"><span>Always </span>Creative.</li>
                            
                            <li><a href="https://github.com/Yxgm" title="Github" target="_blank"><i class="icon-github"></i></a></li>
                            
                            
                            
                            
                            
                            <li class="nolink"><span>Welcome!</span></li>
                        </ul>
                    </nav>
                    <!--// Info-bar -->
                </div>
                <!-- // .container -->
                <div class="learnmore sb-toggle-right">More</div>
                <button type="button" class="navbar-toggle menu-icon sb-toggle-right" title="More">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar before"></span>
                <span class="icon-bar main"></span>
                <span class="icon-bar after"></span>
                </button>
            </div>
            <!-- // .navbar-inner -->
        </div>

        <!-- ============================ Header & Logo bar =========================== -->


      
<section id="intro">
    <div class="container">
        <div class="row col-md-offset-2">
            <div class="col-md-8">
    			<span class="post-meta">
      <time datetime="2022-03-25T06:32:18.394Z" itemprop="datePublished">
          2022-03-25
      </time>
    
</span>
                <h1>实习难点总结</h1>
            </div>
        </div>
        <div class="col-md-8 col-md-offset-2">
      		<h2 id="整体模块思路（toB的增值业务，用户申请应急响应工单系统，快速处理）"><a href="#整体模块思路（toB的增值业务，用户申请应急响应工单系统，快速处理）" class="headerlink" title="整体模块思路（toB的增值业务，用户申请应急响应工单系统，快速处理）"></a>整体模块思路（toB的增值业务，用户申请应急响应工单系统，快速处理）</h2><h4 id="1-用户查看自己当前的所有已申请应急工单，剩余次数，总次数，两栏静态显示组件（显示UI）"><a href="#1-用户查看自己当前的所有已申请应急工单，剩余次数，总次数，两栏静态显示组件（显示UI）" class="headerlink" title="1. 用户查看自己当前的所有已申请应急工单，剩余次数，总次数，两栏静态显示组件（显示UI）"></a>1. 用户查看自己当前的所有已申请应急工单，剩余次数，总次数，两栏静态显示组件（显示UI）</h4><p>封装一个受控组件（数据由组件传入，当然还有背景图片和icon的不同，需要抽离配置文件用require引入，为了以后复用）</p>
<p>在pages页面发送网络请求，将请求回来的数据，塞到我们抽离配置函数返回的对象上去，然后再将对象传入static-layout受控组件中，完成展示。如此，那么以后有相同的UI组件，直接复用即可。</p>
<p>radio中的每一个id，决定父组件下面所有组件的展示。</p>
<h4 id="2-工单概括展示UI，（点击触发工单切换）"><a href="#2-工单概括展示UI，（点击触发工单切换）" class="headerlink" title="2. 工单概括展示UI，（点击触发工单切换）"></a>2. 工单概括展示UI，（点击触发工单切换）</h4><ol>
<li>在子组件的ticket-radio（瑞丢） 中发送了工单列表的请求，请求回来的工单列表数组存在自己的data上，并且对工单数组进行遍历，展示所有的工单，默认第一个工单时active，所以下面展示的工单信息等等都是第一个工单。在最后留有插槽。由外部决定显示UI。</li>
</ol>
<blockquote>
<p>在ticket-radio组件中最后留有插槽，不论多少个工单遍历展示之后，在外部插入（addticket 按钮），保证有序性，并且保证以后最后一个交互按钮的替换</p>
</blockquote>
<ol start="2">
<li><p>在某单个工单上，如果点击某个工单就会向父组件<code>emit</code>事件，父组件接受事件，改变自身<code>data</code>上的<code>current-id</code>，同时传给子组件的<code>id</code>也发生改变，子组件内部用<code>watch </code>监听<code>id</code>，完成响应式刷新子组件</p>
</li>
<li><p>子组件中用<code>watch</code>监听的<code>id</code>，发生变化，即会重新发送一次网络请求，调用<code>reload</code>方法，刷新数据</p>
</li>
</ol>
<blockquote>
<p>开发中的小技巧</p>
<ol>
<li>网络请求回来的数据，使用<code>this.data= Object.assign(&#123;&#125;,data)</code>浅拷贝一份，不直接将data赋值<ol>
<li>将<code>null，undefined</code>之类过滤掉 </li>
<li>该参数不是对象，则会先转成对象</li>
</ol>
</li>
<li>对于一切的网络请求数据，都要用<code>try catch</code>包裹，以防页面挂掉</li>
<li>对于重置data数据，直接使用Object.assign(this.$data,this.$option.data())</li>
</ol>
</blockquote>
<h4 id="2-组件赋能的解释"><a href="#2-组件赋能的解释" class="headerlink" title="2. 组件赋能的解释"></a>2. 组件赋能的解释</h4><p>命令模式，子组件维护自己的api比如说获得数据，校验数据等等。父组件通过ref命令子组件做如何如何的操作，来达到想要的逻辑。</p>
<p>比如说将一个表单封装成一个api，父组件调用一个方法，比如说getFormdata，就可以获得子表单的数据，或者得到表单的校验结果等等，</p>
<p>之后在次级组件中，使用这个表单。这个子组件就是我们直接放在pages上的，他的内部还有有一些提交，重置的一些按钮等等。</p>
<h4 id="3-事件包装成延迟promise对象、目的：-为了让一些功能组件（新增工单，删除工单等等）异步操作同步执行。"><a href="#3-事件包装成延迟promise对象、目的：-为了让一些功能组件（新增工单，删除工单等等）异步操作同步执行。" class="headerlink" title="3. 事件包装成延迟promise对象、目的： 为了让一些功能组件（新增工单，删除工单等等）异步操作同步执行。"></a>3. 事件包装成延迟promise对象、目的： 为了让一些功能组件（新增工单，删除工单等等）异步操作同步执行。</h4><p>发起应急响应事件，createTicket、更新工单事件update、删除工单事件detele</p>
<p>延迟对象回调（父子组件，子组件中封装延迟对象，在子组件某个动作之后，emit到父组件，父组件拿到返回的结果）</p>
<ol>
<li>点击新建工单等，在pages页面，触发子组件的run（）方法，并且将Id传入</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//这是一个新增工单的dialog，点击pages上的新增按钮，触发下面事件，进入子组件的run逻辑中 </span></span><br><span class="line"> <span class="comment">//pages.vue</span></span><br><span class="line"><span class="keyword">const</span> &#123; success &#125; = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">ticketCreator</span>.<span class="title function_">run</span>(<span class="variable language_">this</span>.<span class="property">ticketId</span>);</span><br><span class="line"> <span class="keyword">if</span> (success) &#123;<span class="variable language_">this</span>.<span class="title function_">reloadPage</span>()&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>子组件会返回一个延迟对象promise，给父组件。（待子组件的后续操作）</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ticket-creator.vue 子组件逻辑</span></span><br><span class="line">  <span class="title function_">run</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">deferred</span>) <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">deferred</span>.<span class="property">promise</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">visible</span> = <span class="literal">true</span>;<span class="comment">//组件可见</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">deferred</span> = <span class="keyword">new</span> <span class="title class_">Deferred</span>();<span class="comment">//创建延迟对象</span></span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">deferred</span>.<span class="property">promise</span>;<span class="comment">//将延迟对象promise返回</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>客户填写工单信息，校验表单处理，确认申请，发出网络请求，await堵塞网络请求，待结果返回工单确认后，延迟对象的再 <code>resolve</code>出成功的标识位。同时也要处理异常的逻辑（网络请求失败等）</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  结果，</span></span><br><span class="line"><span class="keyword">await</span> service request..</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">deferred</span>.<span class="title function_">resolve</span>(&#123;<span class="attr">success</span>: <span class="literal">true</span>&#125;)<span class="comment">//延迟对象promise触发resolve，所以pages的异步逻辑返回进入then</span></span><br><span class="line"><span class="comment">//回调，因为pages是 await 直接拿到返回结果，判对，进入刷新页面逻辑（即刷新一些组件）</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>父组件即可接到了<code>resolve</code>出来的结果，判断成功与否，成功的话，进入刷新页面的逻辑，完成新建工单的响应式处理，或者抛出异常，显示降级UI等。</li>
</ol>
<p>​    </p>
<h2 id="PCAP大文件上传需求（1GB以上）"><a href="#PCAP大文件上传需求（1GB以上）" class="headerlink" title="PCAP大文件上传需求（1GB以上）"></a>PCAP大文件上传需求（1GB以上）</h2><blockquote>
<p>由Wireshark（以前称为Ethereal）创建的数据文件，这是用于网络分析的免费程序； 包含在实时网络捕获期间创建的网络数据包数据； 用于“分组嗅探”和分析数据网络特性； 可以使用包含libpcap或WinPcap库的软件进行分析。</p>
</blockquote>
<p> 参考链接：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904046436843527#heading-20">https://juejin.cn/post/6844904046436843527#heading-20</a></p>
<h4 id="contentType-常见的格式"><a href="#contentType-常见的格式" class="headerlink" title="contentType 常见的格式"></a>contentType 常见的格式</h4><ol>
<li>text&#x2F;plain ：纯文本格式。</li>
<li>application&#x2F;json： JSON数据格式。</li>
<li>application&#x2F;x-www-form-urlencoded中默认的encType，form表单数据被编码为key&#x2F;value格式发送到服务器（表单默认的提交数据的格式）。</li>
<li><strong>multipart&#x2F;form-data ： 文件上传格式，需要初始化 FormData对象，然后append键值对，后端需要multipart中间件来做处理。</strong></li>
</ol>
<p>​    哈希计算应该以文件的内容为基准，使用spark-md5计算哈希值</p>
<p>​    另外考虑到如果上传一个超大文件，读取文件内容计算 hash 是非常耗费时间的，并且会 引起 UI 的阻塞，导致页面假死状态，所以我们使用 web-worker 在 worker 线程计算 hash，这样用户仍可以在主界面正常的交互。</p>
<p>​    由于实例化 web-worker 时，参数是一个 js 文件路径且不能跨域，所以我们单独创建一个 hash.js 文件放在 public 目录下，另外在 worker 中也是不允许访问 dom 的，但它提供了 importScripts 函数用于导入外部脚本，通过它导入 spark-md5。</p>
<p>​    在 worker 线程中，接受文件切片 fileChunkList，利用 fileReader 读取每个切片的 ArrayBuffer 并不断传入 spark-md5 中，每计算完一个切片通过 postMessage 向主线程发送一个进度事件，全部完成后将最终的 hash 发送给主线程</p>
<h6 id="1-文件切片上传"><a href="#1-文件切片上传" class="headerlink" title="1. 文件切片上传"></a>1. 文件切片上传</h6><p>​    前端大文件上传核心是<code>利用 Blob.prototype.slice</code>（不老不） 方法，和数组的 slice 方法相似，文件的 slice 方法可以返回<code>原文件的某个切片</code>预先定义好单个切片大小，将文件切分为一个个切片，每一个切片对象需要借助 formData，将文件切片的chunk，单个文件hash（文件哈希值拼接上文件的索引），整体文件哈希，append到formData对象中，<span style="color:red">设置请求头”Content-Type”: “multipart&#x2F;form-data” 的请求头，借助 http 的可并发性 </span>，限制最大并发数，上传多个切片。这样从原本传一个大文件，变成了<code>并发</code>传多个小的文件切片，可以大大减少上传时间.另外由于是并发，传输到服务端的顺序可能会发生变化，因此我们还需要给每个切片记录顺序。</p>
<h6 id="2-如何计算大文件的哈希值-spark-md5"><a href="#2-如何计算大文件的哈希值-spark-md5" class="headerlink" title="2. 如何计算大文件的哈希值 spark-md5"></a>2. 如何计算大文件的哈希值 <a href="https://link.juejin.cn/?target=https://www.npmjs.com/package/spark-md5"><code>spark-md5</code></a></h6><p>​    哈希计算方法:使用spark-md5库，通过文件内容计算，根据文件内容计算出文件的hash值,而不是通过文件名来命名哈希，为了防止大量的js计算，导致页面假死现象，我借鉴react任务分片的思想，同理使用MessageChannel +requestAnimationFrame实现，requestIdleCallback函数的polyfill，利用浏览器的空闲时间，计算文件哈希值，同时此也有worker的解决方案。</p>
<p>​    <mark>使用worker来计算文件hash值是一种标准解决方案，对于这种异步空闲时间计算方式计算hash，更多的是对一个技术的创新和思考，并且在计算文件不是特别大的时候，是可以获得到比worker更高的收益的，因为worker也有通信之间的时耗，是处于技术的思考来做个这个异步浏览器空闲时间计算。</mark></p>
<p>​    构造一个UploadRequestIdle类，挂载MessageChannel的两个端口，挂载计算哈希的函数。当函数调用时，在raf函数中拿到一帧的开始时间，并且计算当前帧的结束时间，将结束时间挂载在该对象上，之后一个port调用postMessage，另一个port2onmessage响应事件，在下一帧刚开始判断浏览器的理想一帧结束时间和当前时间的大小，如果当前时间小于理想一帧结束时间，证明有剩余时间，所以调用计算哈希的函数，不断的读入到闭包变量FileReader对象中，递归调用workloop，当所有的切片都计算完毕，resolve出来最终文件计算的哈希结果。</p>
<p>​    <strong>同时针对raf函数会在页面隐藏的时候，不会执行的特点，做出下以下的两点优化</strong></p>
<ol>
<li>标签页在后台或者隐藏的时候，raf函数不会执行，于是判断了document.hidden，如果页面非活跃的状态，我将deadline的时间延长（1s），为了让计算哈希的函数执行更长时间。</li>
<li>当执行回调的时候，本帧没有空闲的情况下，就在调用一遍raf函数，寻找下一阵的空闲时间。</li>
</ol>
<h6 id="3-总体进度条"><a href="#3-总体进度条" class="headerlink" title="3. 总体进度条"></a>3. 总体进度条</h6><p>​    每一个文件切片都有size数值，我们会在文件上传刚开始拿到文件的总体大小，axios上传有onUploadProgress回调，可以帮我们拿到单个文件上传的进度，用计算属性计算 单个文件进度和单个文件的size计算得到单个文件已上传的大小，遍历切片数组，得出上传文件的size大小，与文件总size相除，在四舍五入2位小数，得到总体进度条数值，塞入UI组件。完成渲染。</p>
<h6 id="4-断点上传"><a href="#4-断点上传" class="headerlink" title="4. 断点上传"></a>4. 断点上传</h6><p>​    断点续传的原理在于前端&#x2F;服务端需要<code>记住</code>已上传的切片，这样下次上传就可以跳过之前已上传的部分，有两种方案实现记忆的功能前端使用 localStorage 记录已上传的切片 hash，服务端保存已上传的切片 hash，前端每次上传前向服务端获取已上传的切片，第一种是前端的解决方案，第二种是服务端，而前端方案有一个缺陷，如果换了个浏览器就失去了记忆的效果，所以这里选后者。</p>
<p>​    文件秒传：仅仅只是视觉效果，计算文件哈希值，在发送请求之前，先校验一下是否存在哈希，存在直接return, ui视觉效果100%；</p>
<p>​    恢复上传：和文件秒传的接口合并，每次上传之前，发送一个请求，返回两种结果：1. 服务器已存在该文件，不需要上传，2. 服务器不存在文件或者存在以及上传的文件切片，并且把已经上传的文件切片哈希返回给前端。所以说我们在上传之前，会拿到已经上传的文件切片哈希，我们遍历切片文件数组filter过滤出没有上传的切片。发送请求。 当两个数组的长度&#x3D;切片总长度的时候，完成上传。</p>
<p>​    暂停（取消）上传：我们在遍历切片axios请求的时候，传入一个数组，axios的config中添加cancelToken属性：new axios.CancelToken(( )&#x3D;&gt;{ cancel &#x3D; c }),在CancelToken的回调中拿到取消请求的函数，构造一下取消函数，push 到传入数组。当我们想要暂停上传的时候，遍历cancelArray，执行cancel函数，结束axios的请求。</p>
<h6 id="5-如何实现限制并发请求？"><a href="#5-如何实现限制并发请求？" class="headerlink" title="5. 如何实现限制并发请求？"></a>5. 如何实现限制并发请求？</h6><p>​    在之前构造请求函数的时候，我们使用柯西化一步，不用promise.all。之后将请求函数数组，扔到我们limit函数中，控制最大并发数。</p>
<p>​    维护一个count常量代表当前上传的切片数量，但是还没有完成，也就是当前切片是loading阶段，不是done，调用loop函数，发出请求同时count++， 当count大于limit限制的时候，将切片请求函数push到一个queue数组中，因为每一个切片上传的请求都是一个promise，上传完毕后在then的回调函数中，再shirt出来一个request函数，递归调用loop函数，最后完成上传所有切片。发送最后的merge请求。</p>
<h6 id="6-切片未上传成功？"><a href="#6-切片未上传成功？" class="headerlink" title="6. 切片未上传成功？"></a>6. 切片未上传成功？</h6><p>​    闭包变量维护一个failMap，当切片上传失败的时候，在失败的回调中map存储失败切片的hash id，当所有切片上传完毕之后，判读Map中是否有值，有值证明有个别切片上传失败(遍历map，再将切片法发送出去)，需要再次上传该切片。然后在发送merge的请求。</p>
<h6 id="7-保证顺序，在每次构造formData对象的时候，将整体文件哈希-索引作为单个文件的哈希"><a href="#7-保证顺序，在每次构造formData对象的时候，将整体文件哈希-索引作为单个文件的哈希" class="headerlink" title="7. 保证顺序，在每次构造formData对象的时候，将整体文件哈希+索引作为单个文件的哈希"></a>7. 保证顺序，在每次构造formData对象的时候，将整体文件哈希+索引作为单个文件的哈希</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">formData.<span class="title function_">append</span>(<span class="string">&#x27;chunk&#x27;</span>, chunk);</span><br><span class="line">formData.<span class="title function_">append</span>(<span class="string">&#x27;hash&#x27;</span>, hash);</span><br><span class="line">formData.<span class="title function_">append</span>(<span class="string">&#x27;filename&#x27;</span>, <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">file</span>.<span class="property">name</span>);</span><br><span class="line">formData.<span class="title function_">append</span>(<span class="string">&#x27;fileHash&#x27;</span>, <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">hash</span>);</span><br></pre></td></tr></table></figure>



<h6 id="8-事件优先级"><a href="#8-事件优先级" class="headerlink" title="8. 事件优先级"></a>8. 事件优先级</h6><p>​    evt 事件执行回调在 evt map 中，啥时候 fireEventListener 啥时候就执行。不管通过鼠标点击从 web input 方式来的，还是 dispatch 的，还是代码 click 的都会同步的调用到 fireEventListener。</p>
<p>​    由于 microtask 被调用的前提是嵌套调用栈必须是 0，你可以发现上述几条中，仅有从 web input 方式来的是无包装调用，即 C++ 直接调用，未进行 JS 方法的包装 。因此只有直接点击存在你最初预计的情况，而 dispatch 的或者是 click 的方式都涉及到 JS <a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E8%B0%83%E7%94%A8%E6%A0%88&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:945234293%7D">调用栈</a>，即此例中 JS 存在 click 方法这一层调用栈深度，只有 click 内 fireEventListener 后，evt map 内的事件回调函数执行后，click 才是真正执行完成。之后的 调用栈 才是 0，perform a microtask checkpoint 才能让 promise 方法执行完。</p>
<p>​    事件回调：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/362096226?utm_id=0">https://www.zhihu.com/question/362096226?utm_id=0</a></p>
<h6 id="9-拓展"><a href="#9-拓展" class="headerlink" title="9. 拓展"></a>9. 拓展</h6><p>Blob：（不老不）二进制类型的大对象，<strong>在 JavaScript 中 Blob 类型的对象表示不可变的类似文件对象的原始数据，注意是不可变的</strong>通过一个Blob对象有size（字节为单位）和type(MIME类型 麦恩 的字符串)两个属性，对于一个英文字符串(空格，符号)是一个字节，汉字3个字节。</p>
<p>Blob对象是不可变的，但是可以对一个Blob进行分割，从而创建新的Blob对象。有类似JavaScript字符串效果。</p>
<p>使用场景：</p>
<blockquote>
<ol>
<li>File对象是特式类型的Blob，所以可用于大文件切片上传，File instanceof Blob &#x2F;&#x2F;true</li>
<li>下载数据存储到blob对象中，设置xhr.responseType&#x3D;”blob”,xhr.onload&#x3D;()&#x3D;&gt;{saveFn(xhr.response)}</li>
<li>blob作为Url</li>
<li>转base64</li>
<li>图片压缩，使用canvas对象的toDataURL方法，在转化为blob对象，append到formData中，进行文件传输。</li>
</ol>
<p>阿宝哥：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/146577946">https://zhuanlan.zhihu.com/p/146577946</a></p>
</blockquote>
<h6 id="10-Blob-vs-ArrayBuffer"><a href="#10-Blob-vs-ArrayBuffer" class="headerlink" title="10. Blob vs ArrayBuffer"></a>10. Blob vs ArrayBuffer</h6><ol>
<li><p>除非你需要使用 ArrayBuffer 提供的写入&#x2F;编辑的能力，否则 Blob 格式可能是最好的。</p>
</li>
<li><p>Blob 对象是不可变的，而 ArrayBuffer 是可以通过 TypedArrays 或 DataView 来操作。</p>
</li>
<li><p>ArrayBuffer 是存在内存中的，可以直接操作。而 Blob 可以位于磁盘、高速缓存内存和其他不可用的位置。</p>
</li>
<li><p>虽然 Blob 可以直接作为参数传递给其他函数，比如 <code>window.URL.createObjectURL()</code>。但是，你可能仍需要 FileReader 之类的 File API 才能与 Blob 一起使用。</p>
</li>
<li><p>Blob 与 ArrayBuffer 对象之间是可以相互转化的：</p>
<ol>
<li>使用 FileReader 的 <code>readAsArrayBuffer()</code> 方法，可以把 Blob 对象转换为 ArrayBuffer 对象；</li>
<li>使用 Blob 构造函数，如 <code>new Blob([new Uint8Array(data]);</code>，可以把 ArrayBuffer 对象转换为 Blob 对象。</li>
</ol>
</li>
</ol>
<h2 id="AOP处理err"><a href="#AOP处理err" class="headerlink" title="AOP处理err"></a>AOP处理err</h2><p>​    aop思想以及oop区别，见业务</p>
<p>​    在实际业务中，一般可以给promise套then方法针对接口错误进行处理或者try catch，但是这样的代码不够简洁。所以我针对这种情况，封装了auto-try-catch函数，自动try catch。</p>
<p>​    将网络请求放在了一个Service对象中，并且构造该对象的proxy对象，我们在调用网络请求的时候，使用该proxy代理该对象，我们重写代理对象的get，set方法，在劫持get，判断是否是函数，如果是函数的话，证明是网络请求函数的调用，不立刻调用函数，而是try catch包裹一层（此处的try catch可以使用一个单独函数来做，也是单一职责的体现），相当于，我们是用了try catch包裹了请求函数，但是并没有侵入到函数内部。</p>
<p>​    之后如果catch住错误的话，我们将err递给ErrHandler处理，因为ErrHandler不在原来的业务逻辑代码中，所以catch住的err，没有当前err的上下文，也就是不知道是哪个接口出了问题，如果想知道是哪个接口出错，那么需要后端配合，在抛出的err中表明是哪个接口出错，前端进行对应的错误上报。这种方式相当于更合理一些。</p>
<p>​    同时还有另一个办法，我们在Service对象中，维护一个可响应变化的变量currentrRequestUrl，在每次网络请求开始的时候，将当前的url赋给currentrRequestUrl，当出错的时候，拿出currentRequestUrl的值，就是出错的接口。此处不存在竞态问题。</p>
<p>​    对于我当时写的需求，并不需要区别对待错误信息，只是单纯的弹出一个通用的降级UI，然后引导用户再去操作一遍。</p>
<h2 id="设计模式的应用"><a href="#设计模式的应用" class="headerlink" title="设计模式的应用"></a>设计模式的应用</h2><h3 id="1-策略模式"><a href="#1-策略模式" class="headerlink" title="1. 策略模式"></a>1. 策略模式</h3><p>​    对于大量的表单校验，会有很多的重复逻辑（比如说校验邮箱，手机号或者一些自定义的校验内容，当某一项没选中的时候，弹出该项label的dialog信息，提示用户），所以说我们将所有的校验函数，放在一个js文件中，exports 出去每一个函数。相当于在该strategy.js文件中包含着所有的校验回调函数，<span style="color:red">有了一个策略对象们对一个表单可以自由组合一个表单的校验规则，达到目的。</span></p>
<p>​    对于一个表单的rules对象就相当于策略模式中的Context上下文，在form的rules对象中定义每个字段的校验规则，在validator字段上定义回调函数，个别规则需要拿到form表单的原数据，比如说第二次校验密码是否一致等情况，所以说在策略函数中柯里化一步，在validator中直接调用策略函数，同时原数据或者表单实例作为第一层的闭包参数传入。拿到表单的原数据，进行比较。（对于第一步的闭包，可以根据实际需求来传入不同的参数）。</p>
<p>​    柯里化之后的校验函数会在参数中拿到rule, value, callback，所以说我们即拿到了当前value和表格原数据，就可以进行校验了。最后callback出去一些自定义的err，提示用户。</p>
<p>​    <span style="color:red">总结：可以根据需求自由组合表单的校验规则，同时对校验函数做了一个集中管理，提高代码复用性，方便之后的拓展。因为代码不仅仅是我在写，以后可能会有别人来维护这个事情的时候，上手速度更快，给公司带来效益。</span></p>
<h3 id="2-命令模式"><a href="#2-命令模式" class="headerlink" title="2. 命令模式"></a>2. 命令模式</h3><p>​    命令模式（Command Pattern）是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。<span style="color:red">命令模式是将行为请求者和行为实现者解耦合的方式。</span>对命令进行封装，将命令和执行命令分隔开。请求的一方发出命令，要求执行某些操作，接受一方收到命令，执行这些操作的真正实现。</p>
<h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ol>
<li>降低了系统耦合度。</li>
<li>命令模式的封装性很好：每个命令都被封装起来，对于客户端来说，需要什么功能就去调用相应的命令，而无需知道命令具体是怎么执行的。比如有一组文件操作的命令：新建文件、复制文件、删除文件。如果把这三个操作都封装成一个命令类，客户端只需要知道有这三个命令类即可，至于命令类中封装好的逻辑，客户端则无需知道。</li>
<li>命令模式的扩展性很好，在命令模式中，在接收者类中一般会对操作进行最基本的封装，命令类则通过对这些基本的操作进行二次封装，当增加新命令的时候，对命令类的编写一般不是从零开始的，有大量的接收者类可供调用，也有大量的命令类可供调用，代码的复用性很好。比如，文件的操作中，我们需要增加一个剪切文件的命令，则只需要把复制文件和删除文件这两个命令组合一下就行了，非常方便。</li>
<li>可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令。</li>
<li>方便实现 Undo 和 Redo 操作。命令模式可以与后面介绍的备忘录模式结合，实现命令的撤销与恢复。</li>
<li>增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，它满足“开闭原则”，对扩展比较灵活。</li>
</ol>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ol>
<li>使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个命令都需要设计一个具体命令类，因此某些系统可能需要大量具体命令类，这将影响命令模式的使用。</li>
</ol>
<h3 id="3-发布订阅"><a href="#3-发布订阅" class="headerlink" title="3. 发布订阅"></a>3. 发布订阅</h3><p>​    发布—订阅模式的优点非常明显，一为时间上的解耦，二为对象之间的解耦。它的应用非常广泛，既可以用在异步编程中，也可以帮助我们完成更松耦合的代码编写。发布—订阅模式还可以用来帮助实现一些别的设计模式，比如中介者模式。从架构上来看，无论是 MVC 还是 MVVM， 都少不了发布—订阅模式的参与，而且JavaScript本身也是一门基于事件驱动的语言。</p>
<p>​    当然，发布—订阅模式也不是完全没有缺点（浪费内存）。创建订阅者本身要消耗一定的时间和内存，而且当你订阅一个消息后，也许此消息最后都未发生，但这个订阅者会始终存在于内存中。另外，发布—订阅模式虽然可以弱化对象之间的联系，但如果过度使用的话，对象和对象之间的必要联系也将被深埋在背后，会导致程序难以跟踪维护和理解。特别是有多个发布者和订阅者（b订阅a的消息并发布给c）嵌套到一起的时候，要跟踪一个bug不是件轻松的事情。</p>
<h2 id="实习中遇到的问题："><a href="#实习中遇到的问题：" class="headerlink" title="实习中遇到的问题："></a>实习中遇到的问题：</h2><p>对于每次切换tab，都会发送网络请求，导致用户的体验感不够好，都要展示降级ui，（loading）之后再跳转。</p>
<p>每次网络请求try 包裹，要有错误处理的UI展示</p>

            <div class="clearfix"></div>
            <hr class="nogutter">
        </div>
        <nav class="m-pagination col-md-8 col-md-offset-2 col-sm-24" role="pagination">
    
    <a class="pull-left" href="/%E5%9F%BA%E7%A1%80%E8%A1%A5%E5%85%85/%E5%9F%BA%E7%A1%80%E9%97%AE%E9%A2%98/" style="float: left;">
        ← 基础问题
    </a>
    
    
    <a class="pull-right" href="/%E4%B8%9A%E5%8A%A1%E5%92%8C%E6%80%9D%E6%83%B3/%E5%BE%AE%E5%89%8D%E7%AB%AF%E6%B5%85%E8%AF%BB/">
        微前端浅读 →
    </a>
    
</nav>

        <div class="col-md-8 col-md-offset-2 col-sm-24"><script type="text/javascript">
  /**
   * 搜狐畅言
   */

  /*
  document.write('<div id="SOHUCS" sid="' + window.location.pathname.slice(1) + '" ></div>');

  window.onload = function () {
    (function () {
      var appid = 'cytXXXX';
      var conf = 'prod_xxxxxxxxxxxxxxxxx';
      var width = window.innerWidth || document.documentElement.clientWidth;
      var loadJs = function (d, a, id) {
        var c = document.getElementsByTagName("head")[0] || document.head || document.documentElement;
        var b = document.createElement("script");
        b.setAttribute("type", "text/javascript");
        b.setAttribute("charset", "UTF-8");
        b.setAttribute("src", d);
        if (id) {
          b.setAttribute("id", id);
        }
        if (typeof a === "function") {
          if (window.attachEvent) {
            b.onreadystatechange = function () {
              var e = b.readyState;
              if (e === "loaded" || e === "complete") {
                b.onreadystatechange = null;
                a()
              }
            }
          } else {
            b.onload = a
          }
        }
        c.appendChild(b)
      };

      loadJs("https://changyan.sohu.com/upload/changyan.js", function () {
        window.changyan.api.config({
          appid: appid,
          conf: conf
        })
      });
    })();
  }
  */

</script>
</div>
    </div>
</section>


      
<!-- ============================ Footer =========================== -->

<footer>
    <div class="container">
            <div class="copy">
                <p>
                    &copy; 2014<script>new Date().getFullYear()>2010&&document.write("-"+new Date().getFullYear());</script>, Content By 盛祥玉. All Rights Reserved.
                </p>
                <p>Theme By <a target="_blank" rel="noopener" href="//go.kieran.top" style="color: #767D84">Kieran</a></p>
            </div>
            <div class="social">
                <ul>
                    
                    <li><a href="https://github.com/Yxgm" title="Github" target="_blank"><i class="icon-github"></i></a>&nbsp;</li>
                    
                    
                    
                    
                    
                </ul>
            </div>
            <div class="clearfix"> </div>
        </div>
</footer>

<!-- ============================ END Footer =========================== -->
      <!-- Load our scripts -->
<!-- Resizable 'on-demand' full-height hero -->
<script type="text/javascript">
    var resizeHero = function () {
        var hero = $(".cover,.heightblock"),
            window1 = $(window);
        hero.css({
            "height": window1.height()
        });
    };

    resizeHero();

    $(window).resize(function () {
        resizeHero();
    });
</script>
<script src="/js/plugins.min.js"></script><!-- Bootstrap core and concatenated plugins always load here -->
<script src="/js/scripts.js"></script><!-- Theme scripts -->


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$('#intro').find('img').each(function(){
  var alt = this.alt;

  if (alt){
    $(this).after('<span class="caption" style="display:none">' + alt + '</span>');
  }

  $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="gallery" />');
});
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



      
</body>
</html>
