<!DOCTYPE html>
<!--[if lte IE 8 ]>
<html class="ie" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<![endif]-->
<!--[if (gte IE 9)|!(IE)]><!-->
<!--
***************  *      *     *
      8          *    *       *
      8          *  *         *
      8          **           *
      8          *  *         *
      8          *    *       *
      8          *      *     *
      8          *        *   ***********    -----Theme By Kieran(http://go.kieran.top)
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN" lang="zh-CN">
<!--<![endif]-->

<head>
  <title>一宿更名_BLOG</title>
  <!-- Meta data -->
    <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" >
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="generator" content="一宿更名_BLOG">
    <meta name="author" content="盛祥玉">
    <meta name="description" content="" />
    <meta name="keywords" content="" />

    <!-- Favicon, (keep icon in root folder) -->
    <link rel="Shortcut Icon" href="/img/favicon.ico" type="image/ico">

    <link rel="alternate" href="/atom.xml" title="一宿更名_BLOG" type="application/atom+xml">
    <link rel="stylesheet" href="/css/all.css" media="screen" type="text/css">
    
    <link rel="stylesheet" href="/highlightjs/vs.css" type="text/css">
    

    <!--[if IE 8]>
    <link rel="stylesheet" type="text/css" href="/css/ie8.css" />
    <![endif]-->

    <!-- jQuery | Load our jQuery, with an alternative source fallback to a local version if request is unavailable -->
    <script src="/js/jquery-1.11.1.min.js"></script>
    <script>window.jQuery || document.write('<script src="js/jquery-1.11.1.min.js"><\/script>')</script>

    <!-- Load these in the <head> for quicker IE8+ load times -->
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="/js/html5shiv.min.js"></script>
    <script src="/js/respond.min.js"></script>
    <![endif]-->

  
  
  

  <style>.col-md-8.col-md-offset-2.opening-statement img{display:none;}</style>
</head>

<!--
<body class="post-template">
-->
<body id="index" class="lightnav animsition">

      <!-- ============================ Off-canvas navigation =========================== -->

    <div class="sb-slidebar sb-right sb-style-overlay sb-momentum-scrolling">
        <div class="sb-close" aria-label="Close Menu" aria-hidden="true">
            <img src="/img/close.png" alt="Close"/>
        </div>
        <!-- Lists in Slidebars -->
        <ul class="sb-menu">
            <li><a href="/" class="animsition-link" title="Home">Home</a></li>
            <li><a href="/archives" class="animsition-link" title="archive">archives</a></li>
            <!-- Dropdown Menu -->
			 
            <li>
                <a class="sb-toggle-submenu">Works<span class="sb-caret"></span></a>
                <ul class="sb-submenu">
                    
                        <li><a href="/" target="_BLANK" class="animsition-link">AAA</a></li>
                    
                        <li><a href="/atom.xml" target="_BLANK" class="animsition-link">BBB</a></li>
                    
                </ul>
            </li>
            
            
        	<li>
        		<a class="sb-toggle-submenu">Categories<span class="sb-caret"></span></a>
            	<ul class="sb-submenu">
				  	
				    <li><a href="/categories/1-Css/" class="animsition-link">1-Css<small>(11)</small></a></li>
				    
				    <li><a href="/categories/1-JavaScript/" class="animsition-link">1-JavaScript<small>(14)</small></a></li>
				    
				    <li><a href="/categories/1-TypeScript/" class="animsition-link">1-TypeScript<small>(3)</small></a></li>
				    
				    <li><a href="/categories/2-React/" class="animsition-link">2-React<small>(10)</small></a></li>
				    
				    <li><a href="/categories/2-React-Hooks/" class="animsition-link">2-React_Hooks<small>(5)</small></a></li>
				    
				    <li><a href="/categories/2-Redux和Router/" class="animsition-link">2-Redux和Router<small>(9)</small></a></li>
				    
				    <li><a href="/categories/2-Vue/" class="animsition-link">2-Vue<small>(12)</small></a></li>
				    
				    <li><a href="/categories/3-Brower/" class="animsition-link">3-Brower<small>(30)</small></a></li>
				    
				    <li><a href="/categories/4-Node/" class="animsition-link">4-Node<small>(1)</small></a></li>
				    
				    <li><a href="/categories/4-Promise/" class="animsition-link">4-Promise<small>(7)</small></a></li>
				    
				    <li><a href="/categories/4-Webpack/" class="animsition-link">4-Webpack<small>(8)</small></a></li>
				    
				    <li><a href="/categories/业务和思想/" class="animsition-link">业务和思想<small>(15)</small></a></li>
				    
				    <li><a href="/categories/前端大项/" class="animsition-link">前端大项<small>(9)</small></a></li>
				    
				    <li><a href="/categories/基础补充/" class="animsition-link">基础补充<small>(5)</small></a></li>
				    
				    <li><a href="/categories/框架差异/" class="animsition-link">框架差异<small>(8)</small></a></li>
				    
				    <li><a href="/categories/算法相关/" class="animsition-link">算法相关<small>(10)</small></a></li>
				    
				    <li><a href="/categories/超脱领悟/" class="animsition-link">超脱领悟<small>(9)</small></a></li>
				    
				    <li><a href="/categories/面试复盘/" class="animsition-link">面试复盘<small>(1)</small></a></li>
				    
				</ul>
        	</li>
			
            
            <li>
                <a class="sb-toggle-submenu">Links<span class="sb-caret"></span></a>
                <ul class="sb-submenu">
                    
                    <li><a target="_blank" rel="noopener" href="http://go.kieran.top/" class="animsition-link">Kieran</a></li>
                    
                    <li><a target="_blank" rel="noopener" href="http://domain.com/" class="animsition-link">Name</a></li>
                    
                </ul>
            </li>
            
        </ul>
        <!-- Lists in Slidebars -->
        <ul class="sb-menu secondary">
            
            <li><a href="/about.html" class="animsition-link" title="about">About</a></li>
            <li><a href="/atom.xml" class="animsition-link" title="rss">RSS</a></li>
        </ul>
    </div>
    
    <!-- ============================ END Off-canvas navigation =========================== -->

    <!-- ============================ #sb-site Main Page Wrapper =========================== -->

    <div id="sb-site">
        <!-- #sb-site - All page content should be contained within this id, except the off-canvas navigation itself -->

        <!-- ============================ Header & Logo bar =========================== -->

        <div id="navigation" class="navbar navbar-fixed-top">
            <div class="navbar-inner">
                <div class="container">
                    <!-- Nav logo -->
                    <div class="logo">
                        <a href="/" title="Logo" class="animsition-link">
                         <img src="/img/logo.png" alt="Logo" width="35px;"/> 
                        </a>
                    </div>
                    <!-- // Nav logo -->
                    <!-- Info-bar -->
                    <nav>
                        <ul class="nav">
                            <li><a href="/" class="animsition-link">一宿更名_BLOG</a></li>
                            <li class="nolink"><span>Always </span>Creative.</li>
                            
                            <li><a href="https://github.com/Yxgm" title="Github" target="_blank"><i class="icon-github"></i></a></li>
                            
                            
                            
                            
                            
                            <li class="nolink"><span>Welcome!</span></li>
                        </ul>
                    </nav>
                    <!--// Info-bar -->
                </div>
                <!-- // .container -->
                <div class="learnmore sb-toggle-right">More</div>
                <button type="button" class="navbar-toggle menu-icon sb-toggle-right" title="More">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar before"></span>
                <span class="icon-bar main"></span>
                <span class="icon-bar after"></span>
                </button>
            </div>
            <!-- // .navbar-inner -->
        </div>

        <!-- ============================ Header & Logo bar =========================== -->


      
<section id="intro">
    <div class="container">
        <div class="row col-md-offset-2">
            <div class="col-md-8">
    			<span class="post-meta">
      <time datetime="2022-03-14T03:00:17.443Z" itemprop="datePublished">
          2022-03-14
      </time>
    
</span>
                <h1></h1>
            </div>
        </div>
        <div class="col-md-8 col-md-offset-2">
      		<p>React在构建用户界面整体遵循函数式的编程理念，即固定的输入有固定的输出，尤其是在推出函数式组件之后，更加强化了组件纯函数的理念。但实际业务中编写的组件不免要产生请求数据、订阅事件、手动操作DOM这些副作用（effect），这样难免让函数组件变得不那么纯，于是React提供use(Layout)Effect的hook，给开发者提供专门管理副作用的方式。</p>
<p>下面我们会从effect的数据结构入手，梳理use(Layout)Effect在render和commit阶段的整体流程。</p>
<h1 id="Effect的数据结构"><a href="#Effect的数据结构" class="headerlink" title="Effect的数据结构"></a>Effect的数据结构</h1><p>关于hook链表结构的基本概念我已经总结过一篇文章：<a target="_blank" rel="noopener" href="https://github.com/neroneroffy/react-source-code-debug/blob/master/docs/Hooks/%E6%A6%82%E8%BF%B0.md">React hooks 的基础概念：hooks链表</a> 。对函数组件来说，其fiber上的memorizedState专门用来存储hooks链表，每一个hook对应链表中的每一个元素。use(Layout)Effect产生的hook会放到fiber.memorizedState上，而它们调用后最终会生成一个effect对象，存储到它们对应hook的memoizedState中，与其他的effect连接成环形链表。</p>
<p>单个的effect对象包括以下几个属性：</p>
<ul>
<li>create: 传入use（Layout）Effect函数的第一个参数，即回调函数</li>
<li>destroy: 回调函数return的函数，在该effect销毁的时候执行</li>
<li>deps: 依赖项</li>
<li>next: 指向下一个effect</li>
<li>tag: effect的类型，区分是useEffect还是useLayoutEffect</li>
</ul>
<p>单纯看effect对象中的字段，很容易和平时的用法联系起来。create函数即我们传入use(Layout)Effect的回调函数，而通过deps，可以控制create是否执行，如需清除effect，则在create函数中return一个新函数（即destroy）即可。</p>
<p>为了理解effect的数据结构，假设有如下组件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">UseEffectExp</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> [ text, setText ] = <span class="title function_">useState</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">    <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;effect1&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;destory1&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="title function_">useLayoutEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;effect2&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;destory2&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>effect<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>挂载到它fiber上memoizedState的hooks链表结构如下</p>
<p><img src="http://neroht.com/hooksLinkedList.png" alt="hooks链表结构"></p>
<p>例如useEffect hook上的memoizedState存储了useEffect 的 effect对象（effect1），next指向useLayoutEffect的effect对象（effect2）。effect2的next又指回effect1.在下面的useLayoutEffect hook中，也是如此的结构。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">fiber.memoizedState ---&gt; useState hook</span><br><span class="line">                             |</span><br><span class="line">                             |</span><br><span class="line">                            next</span><br><span class="line">                             |</span><br><span class="line">                             ↓</span><br><span class="line">                        useEffect hook</span><br><span class="line">                        memoizedState: useEffect的effect对象 ---&gt; useLayoutEffect的effect对象</span><br><span class="line">                             |              ↑__________________________________|</span><br><span class="line">                             |</span><br><span class="line">                            next</span><br><span class="line">                             |</span><br><span class="line">                             ↓</span><br><span class="line">                        useLayoutffect hook</span><br><span class="line">                        memoizedState: useLayoutEffect的effect对象 ---&gt; useEffect的effect对象</span><br><span class="line">                                            ↑___________________________________|</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>effect除了保存在fiber.memoizedState对应的hook中，还会保存在fiber的updateQueue中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fiber.updateQueue ---&gt; useLayoutEffect ----next----&gt; useEffect</span><br><span class="line">                             ↑                          |</span><br><span class="line">                             |__________________________|</span><br></pre></td></tr></table></figure>

<p>现在，我们知道，调用use(Layout)Effect，最后会产生effect链表，这个链表保存在两个地方：</p>
<ul>
<li>fiber.memoizedState的hooks链表中，use(Layout)Effect对应hook元素的memoizedState中。</li>
<li>fiber.updateQueue中，本次更新的updateQueue，它会在本次更新的commit阶段中被处理。</li>
</ul>
<h1 id="流程概述"><a href="#流程概述" class="headerlink" title="流程概述"></a>流程概述</h1><p>基于上面的数据结构，对于use（Layout）Effect来说，React做的事情就是</p>
<ul>
<li><p>render阶段：函数组件开始渲染的时候，创建出对应的hook链表挂载到workInProgress的memoizedState上，并创建effect链表，但是基于上次和本次依赖项的比较结果，<br>创建的effect是有差异的。这一点暂且可以理解为：依赖项有变化，effect可以被处理，否则不会被处理。</p>
</li>
<li><p>commit阶段：异步调度useEffect，layout阶段同步处理useLayoutEffect的effect。等到commit阶段完成，更新应用到页面上之后，开始处理useEffect产生的effect。</p>
</li>
</ul>
<p>第二点提到了一个重点，就是useEffect和useLayoutEffect的执行时机不一样，前者被异步调度，当页面渲染完成后再去执行，不会阻塞页面渲染。<br>后者是在commit阶段新的DOM准备完成，但还未渲染到屏幕之前，同步执行。</p>
<h1 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h1><p>通过整体流程可以看出，effect的整个过程涉及到render阶段和commit阶段。render阶段只创建effect链表，commit阶段去处理这个链表。所有实现的细节都是在围绕effect链表。</p>
<h2 id="render阶段-创建effect链表"><a href="#render阶段-创建effect链表" class="headerlink" title="render阶段-创建effect链表"></a>render阶段-创建effect链表</h2><p>在实际的使用中，我们调用的use(Layout)Effect函数，在挂载和更新的过程是不同的。</p>
<p>挂载时，调用的是<code>mountEffectImpl</code>，它会为use(Layout)Effect这类hook创建一个hook对象，将workInProgressHook指向它，然后在这个fiber节点的flag中加入副作用相关的effectTag。最后，会构建effect链表挂载到fiber的updateQueue，并且也会在hook上的memorizedState挂载effect。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mountEffectImpl</span>(<span class="params">fiberFlags, hookFlags, create, deps</span>): <span class="keyword">void</span> &#123;</span><br><span class="line">  <span class="comment">// 创建hook对象</span></span><br><span class="line">  <span class="keyword">const</span> hook = <span class="title function_">mountWorkInProgressHook</span>();</span><br><span class="line">  <span class="comment">// 获取依赖</span></span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为fiber打上副作用的effectTag</span></span><br><span class="line">  currentlyRenderingFiber.<span class="property">flags</span> |= fiberFlags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建effect链表，挂载到hook的memoizedState上和fiber的updateQueue</span></span><br><span class="line">  hook.<span class="property">memoizedState</span> = <span class="title function_">pushEffect</span>(</span><br><span class="line">    <span class="title class_">HookHasEffect</span> | hookFlags,</span><br><span class="line">    create,</span><br><span class="line">    <span class="literal">undefined</span>,</span><br><span class="line">    nextDeps,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>currentlyRenderingFiber 即 workInProgress节点</p>
</blockquote>
<p>更新时，调用<code>updateEffectImpl</code>，完成effect链表的构建。这个过程中会根据前后依赖项是否变化，从而创建不同的effect对象。具体体现在effect的tag上，如果前后依赖未变，则effect的tag就赋值为传入的hookFlags，否则，在tag中加入HookHasEffect标志位。正是因为这样，在处理effect链表时才可以只处理依赖变化的effect，use(Layout)Effect可以根据它的依赖变化情况来决定是否执行回调。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateEffectImpl</span>(<span class="params">fiberFlags, hookFlags, create, deps</span>): <span class="keyword">void</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> hook = <span class="title function_">updateWorkInProgressHook</span>();</span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  <span class="keyword">let</span> destroy = <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (currentHook !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 从currentHook中获取上一次的effect</span></span><br><span class="line">    <span class="keyword">const</span> prevEffect = currentHook.<span class="property">memoizedState</span>;</span><br><span class="line">    <span class="comment">// 获取上一次effect的destory函数，也就是useEffect回调中return的函数</span></span><br><span class="line">    destroy = prevEffect.<span class="property">destroy</span>;</span><br><span class="line">    <span class="keyword">if</span> (nextDeps !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> prevDeps = prevEffect.<span class="property">deps</span>;</span><br><span class="line">      <span class="comment">// 比较前后依赖，push一个不带HookHasEffect的effect</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">areHookInputsEqual</span>(nextDeps, prevDeps)) &#123;</span><br><span class="line">        <span class="title function_">pushEffect</span>(hookFlags, create, destroy, nextDeps);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  currentlyRenderingFiber.<span class="property">flags</span> |= fiberFlags;</span><br><span class="line">  <span class="comment">// 如果前后依赖有变，在effect的tag中加入HookHasEffect</span></span><br><span class="line">  <span class="comment">// 并将新的effect更新到hook.memoizedState上</span></span><br><span class="line">  hook.<span class="property">memoizedState</span> = <span class="title function_">pushEffect</span>(</span><br><span class="line">    <span class="title class_">HookHasEffect</span> | hookFlags,</span><br><span class="line">    create,</span><br><span class="line">    destroy,</span><br><span class="line">    nextDeps,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在组件挂载和更新时，有一个区别，就是挂载期间调用pushEffect创建effect对象的时候并没有传destroy函数，而更新期间传了，这是因为每次effect执行时，都是先执行前一次的销毁函数，再执行新effect的创建函数。而挂载期间，上一次的effect并不存在，执行创建函数前也就无需先销毁。</p>
</blockquote>
<p>挂载和更新，都调用了pushEffect，它的职责很单纯，就是创建effect对象，构建effect链表，挂到WIP节点的updateQueue上。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">pushEffect</span>(<span class="params">tag, create, destroy, deps</span>) &#123;</span><br><span class="line">  <span class="comment">// 创建effect对象</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">effect</span>: <span class="title class_">Effect</span> = &#123;</span><br><span class="line">    tag,</span><br><span class="line">    create,</span><br><span class="line">    destroy,</span><br><span class="line">    deps,</span><br><span class="line">    <span class="comment">// Circular</span></span><br><span class="line">    <span class="attr">next</span>: (<span class="attr">null</span>: any),</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从workInProgress节点上获取到updateQueue，为构建链表做准备</span></span><br><span class="line">  <span class="keyword">let</span> <span class="attr">componentUpdateQueue</span>: <span class="literal">null</span> | <span class="title class_">FunctionComponentUpdateQueue</span> = (currentlyRenderingFiber.<span class="property">updateQueue</span>: any);</span><br><span class="line">  <span class="keyword">if</span> (componentUpdateQueue === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果updateQueue为空，把effect放到链表中，和它自己形成闭环</span></span><br><span class="line">    componentUpdateQueue = <span class="title function_">createFunctionComponentUpdateQueue</span>();</span><br><span class="line">    <span class="comment">// 将updateQueue赋值给WIP节点的updateQueue，实现effect链表的挂载</span></span><br><span class="line">    currentlyRenderingFiber.<span class="property">updateQueue</span> = (<span class="attr">componentUpdateQueue</span>: any);</span><br><span class="line">    componentUpdateQueue.<span class="property">lastEffect</span> = effect.<span class="property">next</span> = effect;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// updateQueue不为空，将effect接到链表的后边</span></span><br><span class="line">    <span class="keyword">const</span> lastEffect = componentUpdateQueue.<span class="property">lastEffect</span>;</span><br><span class="line">    <span class="keyword">if</span> (lastEffect === <span class="literal">null</span>) &#123;</span><br><span class="line">      componentUpdateQueue.<span class="property">lastEffect</span> = effect.<span class="property">next</span> = effect;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> firstEffect = lastEffect.<span class="property">next</span>;</span><br><span class="line">      lastEffect.<span class="property">next</span> = effect;</span><br><span class="line">      effect.<span class="property">next</span> = firstEffect;</span><br><span class="line">      componentUpdateQueue.<span class="property">lastEffect</span> = effect;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> effect;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>函数组件和类组件的updateQueue都是环状链表</p>
</blockquote>
<p>以上，就是effect链表的构建过程。我们可以看到，effect对象创建出来最终会以两种形式放到两个地方：单个的effect，放到hook.memorizedState上；环状的effect链表，放到fiber节点的updateQueue中。两者各有用途，前者的effect会作为上次更新的effect，为本次创建effect对象提供参照（对比依赖项数组），后者的effect链表会作为最终被执行的主体，带到commit阶段处理。</p>
<h2 id="commit阶段-effect如何被处理"><a href="#commit阶段-effect如何被处理" class="headerlink" title="commit阶段-effect如何被处理"></a>commit阶段-effect如何被处理</h2><p>useEffect和useLayoutEffect，对它们的处理最终都落在处理fiber.updateQueue上，对前者来说，循环updateQueue时只处理包含useEffect这类tag的effect，对后者来说，只处理包含useLayoutEffect这类tag的effect，它们的处理过程都是先执行前一次更新时effect的销毁函数（destroy），再执行新effect的创建函数（create）。</p>
<p>以上是它们的处理过程在微观上的共性，宏观上的区别主要体现在执行时机上。useEffect是在beforeMutation或layout阶段异步调度，然后在本次的更新应用到屏幕上之后再执行，而useLayoutEffect是在layout阶段同步执行的。下面先分析useEffect的处理过程。</p>
<h3 id="useEffect的异步调度"><a href="#useEffect的异步调度" class="headerlink" title="useEffect的异步调度"></a>useEffect的异步调度</h3><blockquote>
<p>与 componentDidMount、componentDidUpdate 不同的是，在浏览器完成布局与绘制之后，传给 useEffect 的函数会延迟调用。<br>这使得它适用于许多常见的副作用场景，比如设置订阅和事件处理等情况，因此不应在函数中执行阻塞浏览器更新屏幕的操作。</p>
</blockquote>
<p>基于useEffect回调<strong>延迟调用（实际上就是异步调用）</strong> 的需求，在实现上利用scheduler的异步调度函数：<code>scheduleCallback</code>，将执行useEffect的动作作为一个任务去调度，这个任务会异步调用。</p>
<p>commit阶段和useEffect真正扯上关系的有三个地方：commit阶段的开始、beforeMutation、layout，涉及到异步调度的是后面两个。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">commitRootImpl</span>(<span class="params">root, renderPriorityLevel</span>) &#123;</span><br><span class="line">  <span class="comment">// 进入commit阶段，先执行一次之前未执行的useEffect</span></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="title function_">flushPassiveEffects</span>();</span><br><span class="line">  &#125; <span class="keyword">while</span> (rootWithPendingPassiveEffects !== <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// beforeMutation阶段的处理函数：commitBeforeMutationEffects内部，</span></span><br><span class="line">      <span class="comment">// 异步调度useEffect</span></span><br><span class="line">      <span class="title function_">commitBeforeMutationEffects</span>();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> rootDidHavePassiveEffects = rootDoesHavePassiveEffects;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (rootDoesHavePassiveEffects) &#123;</span><br><span class="line">    <span class="comment">// 重点，记录有副作用的effect</span></span><br><span class="line">    rootWithPendingPassiveEffects = root;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这三个地方去执行或者调度useEffect有什么用意呢？我们分别来看。</p>
<ul>
<li><p>commit开始，先执行一下useEffect：这和useEffect异步调度的特点有关，它以一般的优先级被调度，这就意味着一旦有更高优先级的任务进入到commit阶段，上一次任务的useEffect还没得到执行。所以在本次更新开始前，需要先将之前的useEffect都执行掉，以保证本次调度的useEffect都是本次更新产生的。</p>
</li>
<li><p>beforeMutation阶段异步调度useEffect：这个是实打实地针对effectList上有副作用的节点，去异步调度useEffect。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">commitBeforeMutationEffects</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; <span class="title class_">Passive</span>) !== <span class="title class_">NoFlags</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果fiber节点上的flags存在Passive调度useEffect</span></span><br><span class="line">      <span class="keyword">if</span> (!rootDoesHavePassiveEffects) &#123;</span><br><span class="line">        rootDoesHavePassiveEffects = <span class="literal">true</span>;</span><br><span class="line">        <span class="title function_">scheduleCallback</span>(<span class="title class_">NormalSchedulerPriority</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">flushPassiveEffects</span>();</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    nextEffect = nextEffect.<span class="property">nextEffect</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为<code>rootDoesHavePassiveEffects</code>的限制，只会发起一次useEffect调度，相当于用一把锁锁住调度状态，避免发起多次调度。</p>
</li>
<li><p>layout阶段填充effect执行数组：真正useEffect执行的时候，实际上是先执行上一次effect的销毁，再执行本次effect的创建。React用两个数组来分别存储销毁函数和<br>创建函数，这两个数组的填充就是在layout阶段，到时候循环释放执行两个数组中的函数即可。</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">commitLifeCycles</span>(<span class="params"></span></span><br><span class="line"><span class="params">  finishedRoot: FiberRoot,</span></span><br><span class="line"><span class="params">  current: Fiber | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  finishedWork: Fiber,</span></span><br><span class="line"><span class="params">  committedLanes: Lanes,</span></span><br><span class="line"><span class="params"></span>): <span class="keyword">void</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (finishedWork.<span class="property">tag</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">FunctionComponent</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">ForwardRef</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">SimpleMemoComponent</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Block</span>: &#123;</span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">      <span class="comment">// layout阶段填充effect执行数组</span></span><br><span class="line">      <span class="title function_">schedulePassiveEffects</span>(finishedWork);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在调用<code>schedulePassiveEffects</code>填充effect执行数组时，有一个重要的地方就是只在包含HasEffect的effectTag的时候，才将effect放到数组内，这一点保证了依赖项有变化再去处理effect。也就是：<strong>如果前后依赖未变，则effect的tag就赋值为传入的hookFlags，否则，在tag中加入HookHasEffect标志位。正是因为这样，在处理effect链表时才可以只处理依赖变化的effect，use(Layout)Effect才可以根据它的依赖变化情况来决定是否执行回调。</strong></p>
<p>schedulePassiveEffects的实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">schedulePassiveEffects</span>(<span class="params">finishedWork: Fiber</span>) &#123;</span><br><span class="line">  <span class="comment">// 获取到函数组件的updateQueue</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">updateQueue</span>: <span class="title class_">FunctionComponentUpdateQueue</span> | <span class="literal">null</span> = (finishedWork.<span class="property">updateQueue</span>: any);</span><br><span class="line">  <span class="comment">// 获取effect链表</span></span><br><span class="line">  <span class="keyword">const</span> lastEffect = updateQueue !== <span class="literal">null</span> ? updateQueue.<span class="property">lastEffect</span> : <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (lastEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> firstEffect = lastEffect.<span class="property">next</span>;</span><br><span class="line">    <span class="keyword">let</span> effect = firstEffect;</span><br><span class="line">    <span class="comment">// 循环effect链表</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123;next, tag&#125; = effect;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        (tag &amp; <span class="title class_">HookPassive</span>) !== <span class="title class_">NoHookEffect</span> &amp;&amp;</span><br><span class="line">        (tag &amp; <span class="title class_">HookHasEffect</span>) !== <span class="title class_">NoHookEffect</span></span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">// 当effect的tag含有HookPassive和HookHasEffect时，向数组中push effect</span></span><br><span class="line">        <span class="title function_">enqueuePendingPassiveHookEffectUnmount</span>(finishedWork, effect);</span><br><span class="line">        <span class="title function_">enqueuePendingPassiveHookEffectMount</span>(finishedWork, effect);</span><br><span class="line">      &#125;</span><br><span class="line">      effect = next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (effect !== firstEffect);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在调用<code>enqueuePendingPassiveHookEffectUnmount</code>和<code>enqueuePendingPassiveHookEffectMount</code>填充数组的时候，还会再异步调度一次useEffect，但这与beforeMutation的调度是互斥的，一旦之前调度过，就不会再调度了，同样是<code>rootDoesHavePassiveEffects</code>起的作用。</p>
<h3 id="执行effect"><a href="#执行effect" class="headerlink" title="执行effect"></a>执行effect</h3><p>此时我们已经知道，effect得以被处理是因为之前的调度以及effect数组的填充。现在到了最后的步骤，执行effect的destroy和create。过程就是先循环待销毁的effect数组，再循环待创建的effect数组，这一过程发生在<code>flushPassiveEffectsImpl</code>函数中。循环的时候每个两项去effect是由于奇数项存储的是当前的fiber。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">flushPassiveEffectsImpl</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 先校验，如果root上没有 Passive efectTag的节点，则直接return</span></span><br><span class="line">  <span class="keyword">if</span> (rootWithPendingPassiveEffects === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行effect的销毁</span></span><br><span class="line">  <span class="keyword">const</span> unmountEffects = pendingPassiveHookEffectsUnmount;</span><br><span class="line">  pendingPassiveHookEffectsUnmount = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; unmountEffects.<span class="property">length</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> effect = ((unmountEffects[i]: any): <span class="title class_">HookEffect</span>);</span><br><span class="line">    <span class="keyword">const</span> fiber = ((unmountEffects[i + <span class="number">1</span>]: any): <span class="title class_">Fiber</span>);</span><br><span class="line">    <span class="keyword">const</span> destroy = effect.<span class="property">destroy</span>;</span><br><span class="line">    effect.<span class="property">destroy</span> = <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> destroy === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="title function_">destroy</span>();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="title function_">captureCommitPhaseError</span>(fiber, error);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 再执行effect的创建</span></span><br><span class="line">  <span class="keyword">const</span> mountEffects = pendingPassiveHookEffectsMount;</span><br><span class="line">  pendingPassiveHookEffectsMount = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; mountEffects.<span class="property">length</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> effect = ((mountEffects[i]: any): <span class="title class_">HookEffect</span>);</span><br><span class="line">    <span class="keyword">const</span> fiber = ((mountEffects[i + <span class="number">1</span>]: any): <span class="title class_">Fiber</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> create = effect.<span class="property">create</span>;</span><br><span class="line">      effect.<span class="property">destroy</span> = <span class="title function_">create</span>();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="title function_">captureCommitPhaseError</span>(fiber, error);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="useLayoutEffect的同步执行"><a href="#useLayoutEffect的同步执行" class="headerlink" title="useLayoutEffect的同步执行"></a>useLayoutEffect的同步执行</h3><p>useLayoutEffect在执行的时候，也是先销毁，再创建。和useEffect不同的是这两者都是同步执行的，前者在mutation阶段执行，后者在layout阶段执行。<br>与useEffect不同的是，它不用数组去存储销毁和创建函数，而是直接操作fiber.updateQueue。</p>
<p>卸载上一次的effect，发生在mutation阶段</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 调用卸载layout effect的函数，传入layout有关的effectTag和说明effect有变化的effectTag：HookLayout | HookHasEffect</span></span><br><span class="line"><span class="title function_">commitHookEffectListUnmount</span>(<span class="title class_">HookLayout</span> | <span class="title class_">HookHasEffect</span>, finishedWork);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">commitHookEffectListUnmount</span>(<span class="params">tag: number, finishedWork: Fiber</span>) &#123;</span><br><span class="line">  <span class="comment">// 获取updateQueue</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">updateQueue</span>: <span class="title class_">FunctionComponentUpdateQueue</span> | <span class="literal">null</span> = (finishedWork.<span class="property">updateQueue</span>: any);</span><br><span class="line">  <span class="keyword">const</span> lastEffect = updateQueue !== <span class="literal">null</span> ? updateQueue.<span class="property">lastEffect</span> : <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环updateQueue上的effect链表</span></span><br><span class="line">  <span class="keyword">if</span> (lastEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> firstEffect = lastEffect.<span class="property">next</span>;</span><br><span class="line">    <span class="keyword">let</span> effect = firstEffect;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> ((effect.<span class="property">tag</span> &amp; tag) === tag) &#123;</span><br><span class="line">        <span class="comment">// 执行销毁</span></span><br><span class="line">        <span class="keyword">const</span> destroy = effect.<span class="property">destroy</span>;</span><br><span class="line">        effect.<span class="property">destroy</span> = <span class="literal">undefined</span>;</span><br><span class="line">        <span class="keyword">if</span> (destroy !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">          <span class="title function_">destroy</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      effect = effect.<span class="property">next</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (effect !== firstEffect);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行本次的effect创建，发生在layout阶段</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用创建layout effect的函数</span></span><br><span class="line"><span class="title function_">commitHookEffectListMount</span>(<span class="title class_">HookLayout</span> | <span class="title class_">HookHasEffect</span>, finishedWork);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">commitHookEffectListMount</span>(<span class="params">tag: number, finishedWork: Fiber</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">updateQueue</span>: <span class="title class_">FunctionComponentUpdateQueue</span> | <span class="literal">null</span> = (finishedWork.<span class="property">updateQueue</span>: any);</span><br><span class="line">  <span class="keyword">const</span> lastEffect = updateQueue !== <span class="literal">null</span> ? updateQueue.<span class="property">lastEffect</span> : <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (lastEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> firstEffect = lastEffect.<span class="property">next</span>;</span><br><span class="line">    <span class="keyword">let</span> effect = firstEffect;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> ((effect.<span class="property">tag</span> &amp; tag) === tag) &#123;</span><br><span class="line">        <span class="comment">// 创建</span></span><br><span class="line">        <span class="keyword">const</span> create = effect.<span class="property">create</span>;</span><br><span class="line">        effect.<span class="property">destroy</span> = <span class="title function_">create</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      effect = effect.<span class="property">next</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (effect !== firstEffect);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>useEffect和useLayoutEffect作为组件的副作用，本质上是一样的。共用一套结构来存储effect链表。整体流程上都是先在render阶段，生成effect，并将它们拼接成链表，存到fiber.updateQueue上，最终带到commit阶段被处理。他们彼此的区别只是最终的执行时机不同，一个异步一个同步，这使得useEffect不会阻塞渲染，而useLayoutEffect会阻塞渲染。</p>

            <div class="clearfix"></div>
            <hr class="nogutter">
        </div>
        <nav class="m-pagination col-md-8 col-md-offset-2 col-sm-24" role="pagination">
    
    <a class="pull-left" href="/2-React_Source/commit%E9%98%B6%E6%AE%B5/mutation/%E8%8A%82%E7%82%B9%E6%8F%92%E5%85%A5/" style="float: left;">
        ← 
    </a>
    
    
    <a class="pull-right" href="/2-React_Source/Concurrent%E6%A8%A1%E5%BC%8F/%E9%A5%A5%E9%A5%BF%E9%97%AE%E9%A2%98/">
         →
    </a>
    
</nav>

        <div class="col-md-8 col-md-offset-2 col-sm-24"><script type="text/javascript">
  /**
   * 搜狐畅言
   */

  /*
  document.write('<div id="SOHUCS" sid="' + window.location.pathname.slice(1) + '" ></div>');

  window.onload = function () {
    (function () {
      var appid = 'cytXXXX';
      var conf = 'prod_xxxxxxxxxxxxxxxxx';
      var width = window.innerWidth || document.documentElement.clientWidth;
      var loadJs = function (d, a, id) {
        var c = document.getElementsByTagName("head")[0] || document.head || document.documentElement;
        var b = document.createElement("script");
        b.setAttribute("type", "text/javascript");
        b.setAttribute("charset", "UTF-8");
        b.setAttribute("src", d);
        if (id) {
          b.setAttribute("id", id);
        }
        if (typeof a === "function") {
          if (window.attachEvent) {
            b.onreadystatechange = function () {
              var e = b.readyState;
              if (e === "loaded" || e === "complete") {
                b.onreadystatechange = null;
                a()
              }
            }
          } else {
            b.onload = a
          }
        }
        c.appendChild(b)
      };

      loadJs("https://changyan.sohu.com/upload/changyan.js", function () {
        window.changyan.api.config({
          appid: appid,
          conf: conf
        })
      });
    })();
  }
  */

</script>
</div>
    </div>
</section>


      
<!-- ============================ Footer =========================== -->

<footer>
    <div class="container">
            <div class="copy">
                <p>
                    &copy; 2014<script>new Date().getFullYear()>2010&&document.write("-"+new Date().getFullYear());</script>, Content By 盛祥玉. All Rights Reserved.
                </p>
                <p>Theme By <a target="_blank" rel="noopener" href="//go.kieran.top" style="color: #767D84">Kieran</a></p>
            </div>
            <div class="social">
                <ul>
                    
                    <li><a href="https://github.com/Yxgm" title="Github" target="_blank"><i class="icon-github"></i></a>&nbsp;</li>
                    
                    
                    
                    
                    
                </ul>
            </div>
            <div class="clearfix"> </div>
        </div>
</footer>

<!-- ============================ END Footer =========================== -->
      <!-- Load our scripts -->
<!-- Resizable 'on-demand' full-height hero -->
<script type="text/javascript">
    var resizeHero = function () {
        var hero = $(".cover,.heightblock"),
            window1 = $(window);
        hero.css({
            "height": window1.height()
        });
    };

    resizeHero();

    $(window).resize(function () {
        resizeHero();
    });
</script>
<script src="/js/plugins.min.js"></script><!-- Bootstrap core and concatenated plugins always load here -->
<script src="/js/scripts.js"></script><!-- Theme scripts -->


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$('#intro').find('img').each(function(){
  var alt = this.alt;

  if (alt){
    $(this).after('<span class="caption" style="display:none">' + alt + '</span>');
  }

  $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="gallery" />');
});
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



      
</body>
</html>
