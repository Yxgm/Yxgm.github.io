<!DOCTYPE html>
<!--[if lte IE 8 ]>
<html class="ie" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<![endif]-->
<!--[if (gte IE 9)|!(IE)]><!-->
<!--
***************  *      *     *
      8          *    *       *
      8          *  *         *
      8          **           *
      8          *  *         *
      8          *    *       *
      8          *      *     *
      8          *        *   ***********    -----Theme By Kieran(http://go.kieran.top)
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN" lang="zh-CN">
<!--<![endif]-->

<head>
  <title>一宿更名_BLOG</title>
  <!-- Meta data -->
    <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" >
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="generator" content="一宿更名_BLOG">
    <meta name="author" content="盛祥玉">
    <meta name="description" content="" />
    <meta name="keywords" content="" />

    <!-- Favicon, (keep icon in root folder) -->
    <link rel="Shortcut Icon" href="/img/favicon.ico" type="image/ico">

    <link rel="alternate" href="/atom.xml" title="一宿更名_BLOG" type="application/atom+xml">
    <link rel="stylesheet" href="/css/all.css" media="screen" type="text/css">
    
    <link rel="stylesheet" href="/highlightjs/vs.css" type="text/css">
    

    <!--[if IE 8]>
    <link rel="stylesheet" type="text/css" href="/css/ie8.css" />
    <![endif]-->

    <!-- jQuery | Load our jQuery, with an alternative source fallback to a local version if request is unavailable -->
    <script src="/js/jquery-1.11.1.min.js"></script>
    <script>window.jQuery || document.write('<script src="js/jquery-1.11.1.min.js"><\/script>')</script>

    <!-- Load these in the <head> for quicker IE8+ load times -->
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="/js/html5shiv.min.js"></script>
    <script src="/js/respond.min.js"></script>
    <![endif]-->

  
  
  

  <style>.col-md-8.col-md-offset-2.opening-statement img{display:none;}</style>
</head>

<!--
<body class="post-template">
-->
<body id="index" class="lightnav animsition">

      <!-- ============================ Off-canvas navigation =========================== -->

    <div class="sb-slidebar sb-right sb-style-overlay sb-momentum-scrolling">
        <div class="sb-close" aria-label="Close Menu" aria-hidden="true">
            <img src="/img/close.png" alt="Close"/>
        </div>
        <!-- Lists in Slidebars -->
        <ul class="sb-menu">
            <li><a href="/" class="animsition-link" title="Home">Home</a></li>
            <li><a href="/archives" class="animsition-link" title="archive">archives</a></li>
            <!-- Dropdown Menu -->
			 
            <li>
                <a class="sb-toggle-submenu">Works<span class="sb-caret"></span></a>
                <ul class="sb-submenu">
                    
                        <li><a href="/" target="_BLANK" class="animsition-link">AAA</a></li>
                    
                        <li><a href="/atom.xml" target="_BLANK" class="animsition-link">BBB</a></li>
                    
                </ul>
            </li>
            
            
        	<li>
        		<a class="sb-toggle-submenu">Categories<span class="sb-caret"></span></a>
            	<ul class="sb-submenu">
				  	
				    <li><a href="/categories/1-Css/" class="animsition-link">1-Css<small>(11)</small></a></li>
				    
				    <li><a href="/categories/1-JavaScript/" class="animsition-link">1-JavaScript<small>(14)</small></a></li>
				    
				    <li><a href="/categories/1-TypeScript/" class="animsition-link">1-TypeScript<small>(3)</small></a></li>
				    
				    <li><a href="/categories/2-React/" class="animsition-link">2-React<small>(10)</small></a></li>
				    
				    <li><a href="/categories/2-React-Hooks/" class="animsition-link">2-React_Hooks<small>(5)</small></a></li>
				    
				    <li><a href="/categories/2-Redux和Router/" class="animsition-link">2-Redux和Router<small>(9)</small></a></li>
				    
				    <li><a href="/categories/2-Vue/" class="animsition-link">2-Vue<small>(12)</small></a></li>
				    
				    <li><a href="/categories/3-Brower/" class="animsition-link">3-Brower<small>(30)</small></a></li>
				    
				    <li><a href="/categories/4-Node/" class="animsition-link">4-Node<small>(1)</small></a></li>
				    
				    <li><a href="/categories/4-Promise/" class="animsition-link">4-Promise<small>(7)</small></a></li>
				    
				    <li><a href="/categories/4-Webpack/" class="animsition-link">4-Webpack<small>(8)</small></a></li>
				    
				    <li><a href="/categories/业务和思想/" class="animsition-link">业务和思想<small>(15)</small></a></li>
				    
				    <li><a href="/categories/前端大项/" class="animsition-link">前端大项<small>(9)</small></a></li>
				    
				    <li><a href="/categories/基础补充/" class="animsition-link">基础补充<small>(5)</small></a></li>
				    
				    <li><a href="/categories/框架差异/" class="animsition-link">框架差异<small>(8)</small></a></li>
				    
				    <li><a href="/categories/算法相关/" class="animsition-link">算法相关<small>(10)</small></a></li>
				    
				    <li><a href="/categories/超脱领悟/" class="animsition-link">超脱领悟<small>(9)</small></a></li>
				    
				    <li><a href="/categories/面试复盘/" class="animsition-link">面试复盘<small>(1)</small></a></li>
				    
				</ul>
        	</li>
			
            
            <li>
                <a class="sb-toggle-submenu">Links<span class="sb-caret"></span></a>
                <ul class="sb-submenu">
                    
                    <li><a target="_blank" rel="noopener" href="http://go.kieran.top/" class="animsition-link">Kieran</a></li>
                    
                    <li><a target="_blank" rel="noopener" href="http://domain.com/" class="animsition-link">Name</a></li>
                    
                </ul>
            </li>
            
        </ul>
        <!-- Lists in Slidebars -->
        <ul class="sb-menu secondary">
            
            <li><a href="/about.html" class="animsition-link" title="about">About</a></li>
            <li><a href="/atom.xml" class="animsition-link" title="rss">RSS</a></li>
        </ul>
    </div>
    
    <!-- ============================ END Off-canvas navigation =========================== -->

    <!-- ============================ #sb-site Main Page Wrapper =========================== -->

    <div id="sb-site">
        <!-- #sb-site - All page content should be contained within this id, except the off-canvas navigation itself -->

        <!-- ============================ Header & Logo bar =========================== -->

        <div id="navigation" class="navbar navbar-fixed-top">
            <div class="navbar-inner">
                <div class="container">
                    <!-- Nav logo -->
                    <div class="logo">
                        <a href="/" title="Logo" class="animsition-link">
                         <img src="/img/logo.png" alt="Logo" width="35px;"/> 
                        </a>
                    </div>
                    <!-- // Nav logo -->
                    <!-- Info-bar -->
                    <nav>
                        <ul class="nav">
                            <li><a href="/" class="animsition-link">一宿更名_BLOG</a></li>
                            <li class="nolink"><span>Always </span>Creative.</li>
                            
                            <li><a href="https://github.com/Yxgm" title="Github" target="_blank"><i class="icon-github"></i></a></li>
                            
                            
                            
                            
                            
                            <li class="nolink"><span>Welcome!</span></li>
                        </ul>
                    </nav>
                    <!--// Info-bar -->
                </div>
                <!-- // .container -->
                <div class="learnmore sb-toggle-right">More</div>
                <button type="button" class="navbar-toggle menu-icon sb-toggle-right" title="More">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar before"></span>
                <span class="icon-bar main"></span>
                <span class="icon-bar after"></span>
                </button>
            </div>
            <!-- // .navbar-inner -->
        </div>

        <!-- ============================ Header & Logo bar =========================== -->


      
<section id="intro">
    <div class="container">
        <div class="row col-md-offset-2">
            <div class="col-md-8">
    			<span class="post-meta">
      <time datetime="2022-03-14T03:00:17.454Z" itemprop="datePublished">
          2022-03-14
      </time>
    
</span>
                <h1></h1>
            </div>
        </div>
        <div class="col-md-8 col-md-offset-2">
      		<h3 id="currentFiber和未连成fiber的vdom进行对比"><a href="#currentFiber和未连成fiber的vdom进行对比" class="headerlink" title="currentFiber和未连成fiber的vdom进行对比"></a>currentFiber和未连成fiber的vdom进行对比</h3><p>上一篇<a target="_blank" rel="noopener" href="https://github.com/neroneroffy/react-source-code-debug/blob/master/docs/render%E9%98%B6%E6%AE%B5/beginWork%E9%98%B6%E6%AE%B5/%E5%A4%84%E7%90%86%E6%9B%B4%E6%96%B0.md">扒一扒React计算状态的原理</a> 之后，我们来分析一下Diff的过程。</p>
<p>fiber上的updateQueue经过React的一番计算之后，这个fiber已经有了新的状态，也就是state，对于类组件来说，state是在render函数里被使用的，<br>既然已经得到了新的state，那么当务之急是执行一次render，得到持有新state的ReactElement。</p>
<p>假设render一次之后得到了大量的ReactElement，而这些ReactElement之中若只有少量需要更新的节点，那么显然不能全部去更新它们，此时就需要有一个diff过程来决定哪些节点是真正需要更新的。</p>
<h2 id="源码结构"><a href="#源码结构" class="headerlink" title="源码结构"></a>源码结构</h2><p>我们以类组件为例，state的计算发生在类组件对应的fiber节点beginWork中的<code>updateClassInstance</code>函数中，在状态计算完毕之后，紧跟着就是去调用<code>finishClassComponent</code>执行diff、<br>打上effectTag（即新版本的flag）。</p>
<blockquote>
<p>打上effectTag可以标识这个fiber发生了怎样的变化，例如：新增（Placement）、更新（Update）、删除（Deletion），这些被打上flag的fiber会在complete阶段被收集起来，形成一个effectList链表，只包含这些需要操作的fiber，最后在commit阶段被更新掉。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateClassComponent</span>(<span class="params"></span></span><br><span class="line"><span class="params">  current: Fiber | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  workInProgress: Fiber,</span></span><br><span class="line"><span class="params">  Component: any,</span></span><br><span class="line"><span class="params">  nextProps: any,</span></span><br><span class="line"><span class="params">  renderLanes: Lanes,</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 计算状态，这一步就是计算新旧状态，决定是否diff，不需要更新的话，就直接复用之前的fiber节点。也是我之前的疑惑点</span></span><br><span class="line">  shouldUpdate = <span class="title function_">updateClassInstance</span>(</span><br><span class="line">    current,</span><br><span class="line">    workInProgress,</span><br><span class="line">    <span class="title class_">Component</span>,</span><br><span class="line">    nextProps,</span><br><span class="line">    renderLanes, </span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行render，进入diff，为fiber打上effectTag</span></span><br><span class="line">  <span class="keyword">const</span> nextUnitOfWork = <span class="title function_">finishClassComponent</span>(</span><br><span class="line">    current,</span><br><span class="line">    workInProgress,</span><br><span class="line">    <span class="title class_">Component</span>,</span><br><span class="line">    shouldUpdate,</span><br><span class="line">    hasContext,</span><br><span class="line">    renderLanes,</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> nextUnitOfWork;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>finishClassComponent</code>函数中，调用<code>reconcileChildFibers</code>去做diff，而<code>reconcileChildFibers</code>实际上就是<code>ChildReconciler</code>，这是diff的核心函数。</p>
<h1 id="Diff的主体"><a href="#Diff的主体" class="headerlink" title="Diff的主体"></a>Diff的主体</h1><p>关于Diff的参与者，在reconcileChildren函数的入参中可以看出</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">workInProgress.<span class="property">child</span> = <span class="title function_">reconcileChildFibers</span>(</span><br><span class="line">  workInProgress,</span><br><span class="line">  current.<span class="property">child</span>,</span><br><span class="line">  nextChildren,</span><br><span class="line">  renderLanes,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li>workInProgress：作为父节点传入，新生成的第一个fiber的return会被指向它。</li>
<li><strong>current.child</strong>：旧fiber节点，diff生成新fiber节点时会用新生成的ReactElement和它作比较。</li>
<li><strong>nextChildren</strong>：新生成的ReactElement，会以它为标准生成新的fiber节点。</li>
<li>renderLanes：本次的渲染优先级，最终会被挂载到新fiber的lanes属性上。</li>
</ul>
<p>可以看出，diff的两个主体是：oldFiber（current.child）和newChildren（nextChildren，新的ReactElement），它们是两个不一样的数据结构。</p>
<p>比如现在有组件<Example/>，它计算完新的状态之后，要基于这两个东西去做diff,分别是<strong>现有fiber树中（current树）<Example/>对应fiber的所有子fiber节点</strong>和**<Example/>的render函数的执行结果，即那些ReactElements**。</p>
<p><Example/>对应fiber的所有子fiber节点：oldFiber</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">current树中</span><br><span class="line"></span><br><span class="line">&lt;<span class="title class_">Example</span>/&gt; fiber</span><br><span class="line">  |</span><br><span class="line">  |</span><br><span class="line">  A --sibling---&gt; B --sibling---&gt; C</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><Example/>的render函数的执行结果，newChildren</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">current fiber 对应的组件render的结果</span><br><span class="line">  [</span><br><span class="line">      &#123;$$typeof: Symbol(react.element), type: &quot;div&quot;, key: &quot;A&quot; &#125;,</span><br><span class="line">      &#123;$$typeof: Symbol(react.element), type: &quot;div&quot;, key: &quot;B&quot; &#125;,</span><br><span class="line">      &#123;$$typeof: Symbol(react.element), type: &quot;div&quot;, key: &quot;B&quot; &#125;,</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure>

<h1 id="Diff的基本原则"><a href="#Diff的基本原则" class="headerlink" title="Diff的基本原则"></a>Diff的基本原则</h1><p>对于新旧两种结构来说，场景有节点自身更新、节点增删、节点移动三种情况。面对复杂的情况，即使最前沿的算法，复杂度也极高。面对这种情况，React以如下策略应对：</p>
<ul>
<li>即使两个元素的子树完全一样，但前后的父级元素不同，依照规则div元素及其子树会完全销毁，并重建一个p元素及其子树，不会尝试复用子树。</li>
<li>使用tag（标签名）和 key识别节点，区分出前后的节点是否变化，以达到尽量复用无变化的节点。</li>
</ul>
<p>因为tag 和 key的存在，所以React可以知道这两个节点只是位置发生了变化。</p>
<h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><p>上面说到diff算法应对三种场景：<code>节点更新、节点增删、节点移动</code>，但一个fiber的子元素有可能是单节点，也有可能是多节点。所以依据这两类节点可以再细分为：</p>
<ul>
<li>单节点更新、单节点增删。</li>
<li>多节点更新、多节点增删、多节点移动。</li>
</ul>
<p>什么是节点的更新呢？对于DOM节点来说，在前后的节点类型（tag）和key都相同的情况下，节点的属性发生了变化，是节点更新。若前后的节点tag或者key不相同，Diff算法会认为新节点和旧节点毫无关系。</p>
<p>以下例子中，key为b的新节点的className发生了变化，是节点更新。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">旧</span><br><span class="line">&lt;div className=&#123;&#x27;a&#x27;&#125; key=&#123;&#x27;a&#x27;&#125;&gt;aa&lt;/div&gt;</span><br><span class="line">&lt;div className=&#123;&#x27;b&#x27;&#125; key=&#123;&#x27;b&#x27;&#125;&gt;bb&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">新</span><br><span class="line">&lt;div className=&#123;&#x27;a&#x27;&#125; key=&#123;&#x27;a&#x27;&#125;&gt;aa&lt;/div&gt;</span><br><span class="line">&lt;div className=&#123;&#x27;bcd&#x27;&#125; key=&#123;&#x27;b&#x27;&#125;&gt;bb&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>以下例子中，新节点的className虽然有变化，但key也变化了，不属于节点更新</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">旧</span><br><span class="line">&lt;div className=&#123;&#x27;a&#x27;&#125; key=&#123;&#x27;a&#x27;&#125;&gt;aa&lt;/div&gt;</span><br><span class="line">&lt;div className=&#123;&#x27;b&#x27;&#125; key=&#123;&#x27;b&#x27;&#125;&gt;bb&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">新</span><br><span class="line">&lt;div className=&#123;&#x27;a&#x27;&#125; key=&#123;&#x27;a&#x27;&#125;&gt;aa&lt;/div&gt;</span><br><span class="line">&lt;div className=&#123;&#x27;bcd&#x27;&#125; key=&#123;&#x27;bbb&#x27;&#125;&gt;bb&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>以下例子中，新节点的className虽然有变化，但tag也变化了，不属于节点更新</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">旧</span><br><span class="line">&lt;div className=&#123;&#x27;a&#x27;&#125; key=&#123;&#x27;a&#x27;&#125;&gt;aa&lt;/div&gt;</span><br><span class="line">&lt;div className=&#123;&#x27;b&#x27;&#125; key=&#123;&#x27;b&#x27;&#125;&gt;bb&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">新</span><br><span class="line">&lt;div className=&#123;&#x27;a&#x27;&#125; key=&#123;&#x27;a&#x27;&#125;&gt;aa&lt;/div&gt;</span><br><span class="line">&lt;p className=&#123;&#x27;bcd&#x27;&#125; key=&#123;&#x27;b&#x27;&#125;&gt;bb&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<p>下面来分开叙述一下单节点和多节点它们各自的更新策略。</p>
<h1 id="单节点"><a href="#单节点" class="headerlink" title="单节点"></a>单节点</h1><p>若组件产出的元素是如下的类型：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;a&quot;</span>&gt;</span>aa<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>那么它最终产出的ReactElement为下面这样（省略了一些与diff相关度不大的属性）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  $$typeof: Symbol(react.element),</span><br><span class="line">  type: &quot;div&quot;,</span><br><span class="line">  key: &quot;a&quot;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单节点指newChildren为单一节点，但是oldFiber的数量不一定，所以实际有如下三种场景：<br><em>为了降低理解成本，我们用简化的节点模型来说明问题，字母代表key。</em></p>
<ul>
<li>单个旧节点<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">旧： A</span><br><span class="line"></span><br><span class="line">新： A</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>多个旧节点<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">旧： A - B - C</span><br><span class="line"></span><br><span class="line">新： B</span><br></pre></td></tr></table></figure></li>
<li>没有旧节点<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">旧： --</span><br><span class="line"></span><br><span class="line">新： A</span><br></pre></td></tr></table></figure></li>
</ul>
<p>对于单节点的diff，其实就只有更新操作，不会涉及位移和位置的变化，单节点的更新会调用<code>reconcileSingleElement</code>函数处理。该函数中对以上三种场景都做了覆盖。但实际上面的情况对于React来说只是两种，oldFiber链是否为空。因此，在实现上也只处理了这两种情况。</p>
<h2 id="oldFiber链不为空"><a href="#oldFiber链不为空" class="headerlink" title="oldFiber链不为空"></a>oldFiber链不为空</h2><p>遍历它们，找到key相同的节点，然后删除剩下的oldFiber节点，再用匹配的oldFiber，newChildren中新节点的props来生成新的fiber节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reconcileSingleElement</span>(<span class="params"></span></span><br><span class="line"><span class="params">  returnFiber: Fiber,</span></span><br><span class="line"><span class="params">  currentFirstChild: Fiber | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  element: ReactElement,</span></span><br><span class="line"><span class="params">  lanes: Lanes</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Fiber</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> key = element.<span class="property">key</span>;</span><br><span class="line">  <span class="keyword">let</span> child = currentFirstChild;</span><br><span class="line">  <span class="keyword">while</span> (child !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (child.<span class="property">key</span> === key) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (child.<span class="property">tag</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="title class_">Fragment</span>:</span><br><span class="line">          ...</span><br><span class="line">        <span class="keyword">case</span> <span class="title class_">Block</span>:</span><br><span class="line">          ...</span><br><span class="line">        <span class="attr">default</span>: &#123;</span><br><span class="line">          <span class="keyword">if</span> (child.<span class="property">elementType</span> === element.<span class="property">type</span>) &#123;</span><br><span class="line">            <span class="comment">// 先删除剩下的oldFiber节点</span></span><br><span class="line">            <span class="title function_">deleteRemainingChildren</span>(returnFiber, child.<span class="property">sibling</span>);</span><br><span class="line">            <span class="comment">// 基于oldFiber节点和新节点的props新建新的fiber节点</span></span><br><span class="line">            <span class="keyword">const</span> existing = <span class="title function_">useFiber</span>(child, element.<span class="property">props</span>);</span><br><span class="line">            existing.<span class="property">ref</span> = <span class="title function_">coerceRef</span>(returnFiber, child, element);</span><br><span class="line">            existing.<span class="property">return</span> = returnFiber;</span><br><span class="line">            <span class="keyword">return</span> existing;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="title function_">deleteRemainingChildren</span>(returnFiber, child);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 没匹配到说明新的fiber节点无法从oldFiber节点新建</span></span><br><span class="line">      <span class="comment">// 删除掉所有oldFiber节点</span></span><br><span class="line">      <span class="title function_">deleteChild</span>(returnFiber, child);</span><br><span class="line">    &#125;</span><br><span class="line">    child = child.<span class="property">sibling</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="oldFiber链为空"><a href="#oldFiber链为空" class="headerlink" title="oldFiber链为空"></a>oldFiber链为空</h2><p>对于没有oldFiber节点的情况，只能新建newFiber节点。逻辑不复杂。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reconcileSingleElement</span>(<span class="params"></span></span><br><span class="line"><span class="params">  returnFiber: Fiber,</span></span><br><span class="line"><span class="params">  currentFirstChild: Fiber | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  element: ReactElement,</span></span><br><span class="line"><span class="params">  lanes: Lanes</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Fiber</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> key = element.<span class="property">key</span>;</span><br><span class="line">  <span class="keyword">let</span> child = currentFirstChild;</span><br><span class="line">  <span class="keyword">while</span> (child !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// oldFiber链非空的处理</span></span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (element.<span class="property">type</span> === <span class="variable constant_">REACT_FRAGMENT_TYPE</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理Fragment类型的节点</span></span><br><span class="line">    ...</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 用产生的ReactElement新建一个fiber节点</span></span><br><span class="line">    <span class="keyword">const</span> created = <span class="title function_">createFiberFromElement</span>(element, returnFiber.<span class="property">mode</span>, lanes);</span><br><span class="line">    created.<span class="property">ref</span> = <span class="title function_">coerceRef</span>(returnFiber, currentFirstChild, element);</span><br><span class="line">    created.<span class="property">return</span> = returnFiber;</span><br><span class="line">    <span class="keyword">return</span> created;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单节点的更新就是这样的处理，真正比较复杂的情况是多节点的diff。因为它涉及到节点的增删和位移。</p>
<h1 id="多节点"><a href="#多节点" class="headerlink" title="多节点"></a>多节点</h1><p>若组件最终产出的DOM元素是如下这样：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;a&quot;</span>&gt;</span>aa<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;b&quot;</span>&gt;</span>bb<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;c&quot;</span>&gt;</span>cc<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;d&quot;</span>&gt;</span>dd<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>那么最终的newChildren为下面这样（省略了一些与diff相关度不大的属性）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;<span class="attr">$$typeof</span>: <span class="title class_">Symbol</span>(react.<span class="property">element</span>), <span class="attr">type</span>: <span class="string">&quot;div&quot;</span>, <span class="attr">key</span>: <span class="string">&quot;a&quot;</span> &#125;,</span><br><span class="line">    &#123;<span class="attr">$$typeof</span>: <span class="title class_">Symbol</span>(react.<span class="property">element</span>), <span class="attr">type</span>: <span class="string">&quot;div&quot;</span>, <span class="attr">key</span>: <span class="string">&quot;b&quot;</span> &#125;,</span><br><span class="line">    &#123;<span class="attr">$$typeof</span>: <span class="title class_">Symbol</span>(react.<span class="property">element</span>), <span class="attr">type</span>: <span class="string">&quot;div&quot;</span>, <span class="attr">key</span>: <span class="string">&quot;c&quot;</span> &#125;,</span><br><span class="line">    &#123;<span class="attr">$$typeof</span>: <span class="title class_">Symbol</span>(react.<span class="property">element</span>), <span class="attr">type</span>: <span class="string">&quot;div&quot;</span>, <span class="attr">key</span>: <span class="string">&quot;d&quot;</span> &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>多节点的变化有以下四种可能性。</p>
<ul>
<li>节点更新<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">旧： A - B - C</span><br><span class="line"></span><br><span class="line">新： `A - B - C`</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>新增节点<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">旧： A - B - C</span><br><span class="line"></span><br><span class="line">新： A - B - C - `D - E`</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>删除节点<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">旧： A - B - C - `D - E`</span><br><span class="line"></span><br><span class="line">新： A - B - C</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>节点移动<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">旧： A - B - C - D - E</span><br><span class="line"></span><br><span class="line">新： A - B - `D - C - E`</span><br><span class="line"></span><br></pre></td></tr></table></figure>
多节点的情况一定是属于这四种情况的任意组合，这种情况会调用<code>reconcileChildrenArray</code>进行diff。按照以上四种情况，它会以newChildren为主体进行最多三轮遍历，但这三轮遍历并不是相互独立的，事实上只有第一轮是从头开始的，之后的每一轮都是上轮结束的断点继续。实际上在平时的实践中，节点自身的更新是最多的，所以Diff算法会优先处理更新的节点。因此四轮遍历又可以按照场景分为两部分：</li>
</ul>
<p>第一轮是针对节点自身属性更新，剩下的两轮依次处理节点的新增、移动，而重点又在移动节点的处理上，所以本文会着重讲解节点更新和节点移动的处理，对删除和新增简单带过。</p>
<h2 id="节点更新"><a href="#节点更新" class="headerlink" title="节点更新"></a>节点更新</h2><p>第一轮从头开始遍历newChildren，会逐个与oldFiber链中的节点进行比较，判断节点的key或者tag是否有变化。</p>
<ul>
<li>没变则从oldFiber节点clone一个props被更新的fiber节点，新的props来自newChildren中的新节点，这样就实现了节点更新。</li>
<li>有变化说明不满足复用条件，立即中断遍历进入下边的遍历。Diff算法的复杂度也因为这个操作大幅降低。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> newIdx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; oldFiber !== <span class="literal">null</span> &amp;&amp; newIdx &lt; newChildren.<span class="property">length</span>; newIdx++) &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新节点，对于DOM节点来说，updateSlot内部会判断</span></span><br><span class="line">  <span class="comment">// key 和 tag。任意一个不同，则返回null</span></span><br><span class="line">  <span class="keyword">const</span> newFiber = <span class="title function_">updateSlot</span>(</span><br><span class="line">    returnFiber,</span><br><span class="line">    oldFiber,</span><br><span class="line">    newChildren[newIdx],</span><br><span class="line">    lanes,</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// newFiber为null则说明当前的节点不是更新的场景，中止这一轮循环</span></span><br><span class="line">  <span class="keyword">if</span> (newFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">      oldFiber = nextOldFiber;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看一个例子，假设新旧的节点如下：</p>
<p>旧： A - B - <code>C - D</code> - E</p>
<p>新： A - B - <code>D - C</code></p>
<p>在本轮遍历中，会遍历<code>A - B - D - C</code>。A和B都是key没变的节点，可以直接复用，但当遍历到D时，发现key变化了，跳出当前遍历。</p>
<p>例子中A 和 B是自身发生更新的节点，后面的D 和 C我们看到它的位置相对于oldFiber链发生了变化，会往下走到处理移动节点的循环中。</p>
<p><strong>关于移动节点的参照物</strong></p>
<p>为了方便说明，把保留在原位的节点称为固定节点。经过这次循环的处理，可以看出固定节点是A 和 B。在newChildren中，最靠右的固定节点的位置至关重要，对于后续的移动节点的处理来说，它的意义是提供参考位置。所以，每当处理到最后一个固定节点时，要记住此时它的位置，这个位置就是<code>lastPlacedIndex</code>。关键代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let newIdx = 0;</span><br><span class="line">for (; oldFiber !== null &amp;&amp; newIdx &lt; newChildren.length; newIdx++) &#123;</span><br><span class="line">   ...</span><br><span class="line">   // 跳出逻辑</span><br><span class="line">   ...</span><br><span class="line">   // 如果不跳出，记录最新的固定节点的位置</span><br><span class="line">   lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>placeChild</code>方法实际上是移动节点的方法，但当节点无需移动的时候，会返回当前节点的位置，对于固定节点来说，因为无需移动，所以返回的就是固定节点的index。</p>
<h2 id="节点删除"><a href="#节点删除" class="headerlink" title="节点删除"></a>节点删除</h2><p>我们没有提到对删除节点的处理，实际上删除节点比较简单。</p>
<p>旧： A - B - C - <code>D - E</code></p>
<p>新： A - B - C    </p>
<p>因为遍历的是newChildren，当它遍历结束，但oldFiber链还没有遍历完，那么说明剩下的节点都要被删除。直接在oldFiber节点上标记Deletion的effectTag来实现删除。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (newIdx === newChildren.<span class="property">length</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 新子节点遍历完，说明剩下的oldFiber都是没用的了，可以删除</span></span><br><span class="line">  <span class="title function_">deleteRemainingChildren</span>(returnFiber, oldFiber);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> resultingFirstChild;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>deleteRemainingChildren</code>调用了<code>deleteChild</code>，值得注意的是，删除不仅仅是标记了effectTag为Deletion，还会将这个被删除的fiber节点添加到父级的effectList中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deleteChild</span>(<span class="params">returnFiber: Fiber, childToDelete: Fiber</span>): <span class="keyword">void</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">const</span> last = returnFiber.<span class="property">lastEffect</span>;</span><br><span class="line">  <span class="comment">// 将要删除的child添加到父级fiber的effectList中，并添加上effectTag为删除</span></span><br><span class="line">  <span class="keyword">if</span> (last !== <span class="literal">null</span>) &#123;</span><br><span class="line">    last.<span class="property">nextEffect</span> = childToDelete;</span><br><span class="line">    returnFiber.<span class="property">lastEffect</span> = childToDelete;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    returnFiber.<span class="property">firstEffect</span> = returnFiber.<span class="property">lastEffect</span> = childToDelete;</span><br><span class="line">  &#125;</span><br><span class="line">  childToDelete.<span class="property">nextEffect</span> = <span class="literal">null</span>;</span><br><span class="line">  childToDelete.<span class="property">effectTag</span> = <span class="title class_">Deletion</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="节点新增"><a href="#节点新增" class="headerlink" title="节点新增"></a>节点新增</h2><p>新增节点的场景也很好理解，当oldFiber链遍历完，但newChildren还没遍历完，那么余下的节点都属于新插入的节点，会新建fiber节点并以sibling为指针连成fiber链。</p>
<p>旧： A - B - C</p>
<p>新： A - B - C - <code>D - E</code></p>
<p>插入的逻辑（省略了相关度不高的代码）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">if (oldFiber === null) &#123;</span><br><span class="line">  // 旧的遍历完了，意味着剩下的都是新增的了</span><br><span class="line">  for (; newIdx &lt; newChildren.length; newIdx++) &#123;</span><br><span class="line">    // 首先创建newFiber</span><br><span class="line">    const newFiber = createChild(returnFiber, newChildren[newIdx], lanes);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    // 再将newFiber连接成以sibling为指针的单向链表</span><br><span class="line">    if (previousNewFiber === null) &#123;</span><br><span class="line">      resultingFirstChild = newFiber;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      previousNewFiber.sibling = newFiber;</span><br><span class="line">    &#125;</span><br><span class="line">    previousNewFiber = newFiber;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return resultingFirstChild;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="节点移动"><a href="#节点移动" class="headerlink" title="节点移动"></a>节点移动</h2><p>节点的移动是如下场景：</p>
<p>旧 A - B - <code>C - D - E - F</code></p>
<p>新 A - B - <code>D - C - E</code></p>
<p>经过第一轮遍历的处理，固定节点为A B，最新的固定节点的位置（lastPlacedIndex）为1（B的位置）。此时oldFiber链中还剩C - D - E - F，newChildren中还剩D - C - E。</p>
<p>接下来的逻辑对于位置不一样的节点，它自己会先更新再移动。因为此时剩余的节点位置变了，更新又要复用oldFiber节点，所以为了在更新时方便查找，会将剩余的oldFiber节点<br>放入一个以key为键，值为oldFiber节点的map中。称为<code>existingChildren</code>。</p>
<p>由于newChildren 和 oldFiber节点都没遍历完，说明需要移动位置。此刻需要明确一点，就是<strong>这些节点都在最新的固定节点的右边</strong>。</p>
<p>移动的逻辑是：newChildren中剩余的节点，都是不确定要不要移动的，遍历它们，每一个都去看看这个节点在oldFiber链中的位置（旧位置），遍历到的节点有它在newChildren中的位置（新位置）：</p>
<p>如果旧位置在lastPlacedIndex的<strong>右边</strong>，说明这个节点位置不变。<br>原因是旧位置在lastPlacedIndex的<strong>右边</strong>，而新节点的位置也在它的<strong>右边</strong>，所以它的位置没变化。因为位置不变，所以它成了固定节点，把lastPlacedIndex更新成新位置。</p>
<p>如果旧位置在lastPlacedIndex的左边，当前这个节点的位置要往右挪。<br>原因是旧位置在lastPlacedIndex的<strong>左边</strong>，新位置却在lastPlacedIndex的<strong>右边</strong>，所以它要往右挪，但它不是固定节点。此时无需更新lastPlacedIndex。</p>
<p>我们来用上边的例子过一下这部分逻辑。</p>
<p>旧 A - B - <code>C - D - E - F</code></p>
<p>新 A - B - <code>D - C - E</code></p>
<p>位置固定部分 A - B，最右侧的固定节点为B，lastPlacedIndex为<code>1</code>。这时剩余oldFiber链为C - D - E - F，existingChildren为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    C: &#x27;节点C&#x27;,</span><br><span class="line">    D: &#x27;节点D&#x27;,</span><br><span class="line">    E: &#x27;节点E&#x27;,</span><br><span class="line">    F: &#x27;节点F&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>newChildren的剩余部分D - C - E继续遍历。</p>
<p>首先遍历到D，D在oldFiber链中（A - B - C - D - E）的位置为3<br>3 &gt; <code>1</code>，oldFiber中D的位置在B的右边，newChildren中也是如此，所以D的位置不动，此时最新的固定节点变成了<code>D</code>，更新lastPlacedIndex为<code>3</code>。</p>
<p>并从existingChildren中删除D，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    C: &#x27;节点C&#x27;,</span><br><span class="line">    E: &#x27;节点E&#x27;,</span><br><span class="line">    F: &#x27;节点F&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再遍历到C，C在oldFiber链中（A - B - C - D - E）的索引为2<br>2 &lt; <code>3</code>，C原来在最新固定节点（<code>D</code>）的左边，newChildren中C在<code>D</code>的右边，所以要给它移动到右边。</p>
<p>并从existingChildren中删除C，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    E: &#x27;节点E&#x27;,</span><br><span class="line">    F: &#x27;节点F&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再遍历到E，E在oldFiber链中（A - B - C - D - E）的位置为4<br>4 &gt; <code>3</code>，oldFiber链中E位置在<code>D</code>的位置的右边，新位置中也是如此，所以E的位置不动，此时最新的固定节点变成了<code>E</code>，更新lastPlacedIndex为<code>4</code>。</p>
<p>并从existingChildren中删除E，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    F: &#x27;节点F&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候newChildren都处理完了，针对移动节点的遍历结束。</p>
<p>此时还剩一个F节点，是在oldFiber链中的，因为newChildren都处理完了，所以将它删除即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">existingChildren.forEach(child =&gt; deleteChild(returnFiber, child));</span><br></pre></td></tr></table></figure>

<p>可以看到，节点的移动是以最右侧的固定节点位置作为参照的。这些固定节点是指位置未发生变化的节点。每次对比节点是否需要移动之后，<br>及时更新固定节点非常重要。</p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>了解了上边的多节点diff原理后，将上边的关键点匹配到源码上更方便能进一步理解。下面放出带有详细注释的源码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reconcileChildrenArray</span>(<span class="params"></span></span><br><span class="line"><span class="params">  returnFiber: Fiber,</span></span><br><span class="line"><span class="params">  currentFirstChild: Fiber | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  newChildren: <span class="built_in">Array</span>&lt;*&gt;,</span></span><br><span class="line"><span class="params">  lanes: Lanes,</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Fiber</span> | <span class="literal">null</span> &#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * returnFiber：currentFirstChild的父级fiber节点</span></span><br><span class="line"><span class="comment">  * currentFirstChild：当前执行更新任务的WIP（fiber）节点</span></span><br><span class="line"><span class="comment">  * newChildren：组件的render方法渲染出的新的ReactElement节点</span></span><br><span class="line"><span class="comment">  * lanes：优先级相关</span></span><br><span class="line"><span class="comment">  * */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// resultingFirstChild是diff之后的新fiber链表的第一个fiber。</span></span><br><span class="line">  <span class="keyword">let</span> <span class="attr">resultingFirstChild</span>: <span class="title class_">Fiber</span> | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// resultingFirstChild是新链表的第一个fiber。</span></span><br><span class="line">  <span class="comment">// previousNewFiber用来将后续的新fiber接到第一个fiber之后</span></span><br><span class="line">  <span class="keyword">let</span> <span class="attr">previousNewFiber</span>: <span class="title class_">Fiber</span> | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// oldFiber节点，新的child节点会和它进行比较</span></span><br><span class="line">  <span class="keyword">let</span> oldFiber = currentFirstChild;</span><br><span class="line">  <span class="comment">// 存储固定节点的位置</span></span><br><span class="line">  <span class="keyword">let</span> lastPlacedIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 存储遍历到的新节点的索引</span></span><br><span class="line">  <span class="keyword">let</span> newIdx = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 记录目前遍历到的oldFiber的下一个节点</span></span><br><span class="line">  <span class="keyword">let</span> nextOldFiber = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 该轮遍历来处理节点更新，依据节点是否可复用来决定是否中断遍历</span></span><br><span class="line">  <span class="keyword">for</span> (; oldFiber !== <span class="literal">null</span> &amp;&amp; newIdx &lt; newChildren.<span class="property">length</span>; newIdx++) &#123;</span><br><span class="line">    <span class="comment">// newChildren遍历完了，oldFiber链没有遍历完，此时需要中断遍历</span></span><br><span class="line">    <span class="keyword">if</span> (oldFiber.<span class="property">index</span> &gt; newIdx) &#123;</span><br><span class="line">      nextOldFiber = oldFiber;</span><br><span class="line">      oldFiber = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 用nextOldFiber存储当前遍历到的oldFiber的下一个节点</span></span><br><span class="line">      nextOldFiber = oldFiber.<span class="property">sibling</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生成新的节点，判断key与tag是否相同就在updateSlot中</span></span><br><span class="line">    <span class="comment">// 对DOM类型的元素来说，key 和 tag都相同才会复用oldFiber</span></span><br><span class="line">    <span class="comment">// 并返回出去，否则返回null</span></span><br><span class="line">    <span class="keyword">const</span> newFiber = <span class="title function_">updateSlot</span>(</span><br><span class="line">      returnFiber,</span><br><span class="line">      oldFiber,</span><br><span class="line">      newChildren[newIdx],</span><br><span class="line">      lanes,</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// newFiber为 null说明 key 或 tag 不同，节点不</span></span><br><span class="line">    <span class="comment">// 可复用，中断遍历</span></span><br><span class="line">    <span class="keyword">if</span> (newFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (oldFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// oldFiber 为null说明oldFiber此时也遍历完了</span></span><br><span class="line">        <span class="comment">// 是以下场景，D为新增节点</span></span><br><span class="line">        <span class="comment">// 旧 A - B - C</span></span><br><span class="line">        <span class="comment">// 新 A - B - C - D</span></span><br><span class="line">        oldFiber = nextOldFiber;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (shouldTrackSideEffects) &#123;</span><br><span class="line">      <span class="comment">// shouldTrackSideEffects 为true表示是更新过程</span></span><br><span class="line">      <span class="keyword">if</span> (oldFiber &amp;&amp; newFiber.<span class="property">alternate</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// newFiber.alternate 等同于 oldFiber.alternate</span></span><br><span class="line">        <span class="comment">// oldFiber为WIP节点，它的alternate 就是 current节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// oldFiber存在，并且经过更新后的新fiber节点它还没有current节点,</span></span><br><span class="line">        <span class="comment">// 说明更新后展现在屏幕上不会有current节点，而更新后WIP</span></span><br><span class="line">        <span class="comment">// 节点会称为current节点，所以需要删除已有的WIP节点</span></span><br><span class="line">        <span class="title function_">deleteChild</span>(returnFiber, oldFiber);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录固定节点的位置</span></span><br><span class="line">    lastPlacedIndex = <span class="title function_">placeChild</span>(newFiber, lastPlacedIndex, newIdx);</span><br><span class="line">    <span class="comment">// 将新fiber连接成以sibling为指针的单向链表</span></span><br><span class="line">    <span class="keyword">if</span> (previousNewFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">      resultingFirstChild = newFiber;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      previousNewFiber.<span class="property">sibling</span> = newFiber;</span><br><span class="line">    &#125;</span><br><span class="line">    previousNewFiber = newFiber;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将oldFiber节点指向下一个，与newChildren的遍历同步移动</span></span><br><span class="line">    oldFiber = nextOldFiber;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理节点删除。新子节点遍历完，说明剩下的oldFiber都是没用的了，可以删除.</span></span><br><span class="line">  <span class="keyword">if</span> (newIdx === newChildren.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="comment">// newChildren遍历结束，删除掉oldFiber链中的剩下的节点</span></span><br><span class="line">    <span class="title function_">deleteRemainingChildren</span>(returnFiber, oldFiber);</span><br><span class="line">    <span class="keyword">return</span> resultingFirstChild;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理新增节点。旧的遍历完了，能复用的都复用了，所以意味着新的都是新插入的了</span></span><br><span class="line">  <span class="keyword">if</span> (oldFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (; newIdx &lt; newChildren.<span class="property">length</span>; newIdx++) &#123;</span><br><span class="line">      <span class="comment">// 基于新生成的ReactElement创建新的Fiber节点</span></span><br><span class="line">      <span class="keyword">const</span> newFiber = <span class="title function_">createChild</span>(returnFiber, newChildren[newIdx], lanes);</span><br><span class="line">      <span class="keyword">if</span> (newFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 记录固定节点的位置lastPlacedIndex</span></span><br><span class="line">      lastPlacedIndex = <span class="title function_">placeChild</span>(newFiber, lastPlacedIndex, newIdx);</span><br><span class="line">      <span class="comment">// 将新生成的fiber节点连接成以sibling为指针的单向链表</span></span><br><span class="line">      <span class="keyword">if</span> (previousNewFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">        resultingFirstChild = newFiber;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        previousNewFiber.<span class="property">sibling</span> = newFiber;</span><br><span class="line">      &#125;</span><br><span class="line">      previousNewFiber = newFiber;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultingFirstChild;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 执行到这是都没遍历完的情况，把剩余的旧子节点放入一个以key为键,值为oldFiber节点的map中</span></span><br><span class="line">  <span class="comment">// 这样在基于oldFiber节点新建新的fiber节点时，可以通过key快速地找出oldFiber</span></span><br><span class="line">  <span class="keyword">const</span> existingChildren = <span class="title function_">mapRemainingChildren</span>(returnFiber, oldFiber);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 节点移动</span></span><br><span class="line">  <span class="keyword">for</span> (; newIdx &lt; newChildren.<span class="property">length</span>; newIdx++) &#123;</span><br><span class="line">    <span class="comment">// 基于map中的oldFiber节点来创建新fiber</span></span><br><span class="line">    <span class="keyword">const</span> newFiber = <span class="title function_">updateFromMap</span>(</span><br><span class="line">      existingChildren,</span><br><span class="line">      returnFiber,</span><br><span class="line">      newIdx,</span><br><span class="line">      newChildren[newIdx],</span><br><span class="line">      lanes,</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (newFiber !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (shouldTrackSideEffects) &#123;</span><br><span class="line">        <span class="keyword">if</span> (newFiber.<span class="property">alternate</span> !== <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 因为newChildren中剩余的节点有可能和oldFiber节点一样,只是位置换了，</span></span><br><span class="line">          <span class="comment">// 但也有可能是是新增的.</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">// 如果newFiber的alternate不为空，则说明newFiber不是新增的。</span></span><br><span class="line">          <span class="comment">// 也就说明着它是基于map中的oldFiber节点新建的,意味着oldFiber已经被使用了,所以需</span></span><br><span class="line">          <span class="comment">// 要从map中删去oldFiber</span></span><br><span class="line">          existingChildren.<span class="title function_">delete</span>(</span><br><span class="line">            newFiber.<span class="property">key</span> === <span class="literal">null</span> ? newIdx : newFiber.<span class="property">key</span>,</span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 移动节点，多节点diff的核心，这里真正会实现节点的移动</span></span><br><span class="line">      lastPlacedIndex = <span class="title function_">placeChild</span>(newFiber, lastPlacedIndex, newIdx);</span><br><span class="line">      <span class="comment">// 将新fiber连接成以sibling为指针的单向链表</span></span><br><span class="line">      <span class="keyword">if</span> (previousNewFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">        resultingFirstChild = newFiber;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        previousNewFiber.<span class="property">sibling</span> = newFiber;</span><br><span class="line">      &#125;</span><br><span class="line">      previousNewFiber = newFiber;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (shouldTrackSideEffects) &#123;</span><br><span class="line">    <span class="comment">// 此时newChildren遍历完了，该移动的都移动了，那么删除剩下的oldFiber</span></span><br><span class="line">    existingChildren.<span class="title function_">forEach</span>(<span class="function"><span class="params">child</span> =&gt;</span> <span class="title function_">deleteChild</span>(returnFiber, child));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> resultingFirstChild;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Diff算法通过key和tag来对节点进行取舍，可直接将复杂的比对拦截掉，然后降级成节点的移动和增删这样比较简单的操作。<br>对oldFiber和新的ReactElement节点的比对，将会生成新的fiber节点，同时标记上effectTag，这些fiber会被连到workInProgress树中，作为新的WIP节点。<br>树的结构因此被一点点地确定，而新的WIP节点也基本定型。</p>
<p>这意味着，在diff过后，workInProgress节点的beginWork节点就完成了。接下来会进入completeWork阶段。</p>

            <div class="clearfix"></div>
            <hr class="nogutter">
        </div>
        <nav class="m-pagination col-md-8 col-md-offset-2 col-sm-24" role="pagination">
    
    <a class="pull-left" href="/2-React_Source/commit%E9%98%B6%E6%AE%B5/mutation/%E8%8A%82%E7%82%B9%E6%9B%B4%E6%96%B0/" style="float: left;">
        ← 
    </a>
    
    
    <a class="pull-right" href="/2-React_Source/commit%E9%98%B6%E6%AE%B5/mutation/%E8%8A%82%E7%82%B9%E5%88%A0%E9%99%A4/">
         →
    </a>
    
</nav>

        <div class="col-md-8 col-md-offset-2 col-sm-24"><script type="text/javascript">
  /**
   * 搜狐畅言
   */

  /*
  document.write('<div id="SOHUCS" sid="' + window.location.pathname.slice(1) + '" ></div>');

  window.onload = function () {
    (function () {
      var appid = 'cytXXXX';
      var conf = 'prod_xxxxxxxxxxxxxxxxx';
      var width = window.innerWidth || document.documentElement.clientWidth;
      var loadJs = function (d, a, id) {
        var c = document.getElementsByTagName("head")[0] || document.head || document.documentElement;
        var b = document.createElement("script");
        b.setAttribute("type", "text/javascript");
        b.setAttribute("charset", "UTF-8");
        b.setAttribute("src", d);
        if (id) {
          b.setAttribute("id", id);
        }
        if (typeof a === "function") {
          if (window.attachEvent) {
            b.onreadystatechange = function () {
              var e = b.readyState;
              if (e === "loaded" || e === "complete") {
                b.onreadystatechange = null;
                a()
              }
            }
          } else {
            b.onload = a
          }
        }
        c.appendChild(b)
      };

      loadJs("https://changyan.sohu.com/upload/changyan.js", function () {
        window.changyan.api.config({
          appid: appid,
          conf: conf
        })
      });
    })();
  }
  */

</script>
</div>
    </div>
</section>


      
<!-- ============================ Footer =========================== -->

<footer>
    <div class="container">
            <div class="copy">
                <p>
                    &copy; 2014<script>new Date().getFullYear()>2010&&document.write("-"+new Date().getFullYear());</script>, Content By 盛祥玉. All Rights Reserved.
                </p>
                <p>Theme By <a target="_blank" rel="noopener" href="//go.kieran.top" style="color: #767D84">Kieran</a></p>
            </div>
            <div class="social">
                <ul>
                    
                    <li><a href="https://github.com/Yxgm" title="Github" target="_blank"><i class="icon-github"></i></a>&nbsp;</li>
                    
                    
                    
                    
                    
                </ul>
            </div>
            <div class="clearfix"> </div>
        </div>
</footer>

<!-- ============================ END Footer =========================== -->
      <!-- Load our scripts -->
<!-- Resizable 'on-demand' full-height hero -->
<script type="text/javascript">
    var resizeHero = function () {
        var hero = $(".cover,.heightblock"),
            window1 = $(window);
        hero.css({
            "height": window1.height()
        });
    };

    resizeHero();

    $(window).resize(function () {
        resizeHero();
    });
</script>
<script src="/js/plugins.min.js"></script><!-- Bootstrap core and concatenated plugins always load here -->
<script src="/js/scripts.js"></script><!-- Theme scripts -->


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$('#intro').find('img').each(function(){
  var alt = this.alt;

  if (alt){
    $(this).after('<span class="caption" style="display:none">' + alt + '</span>');
  }

  $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="gallery" />');
});
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



      
</body>
</html>
