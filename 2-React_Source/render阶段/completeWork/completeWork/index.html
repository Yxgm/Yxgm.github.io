<!DOCTYPE html>
<!--[if lte IE 8 ]>
<html class="ie" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<![endif]-->
<!--[if (gte IE 9)|!(IE)]><!-->
<!--
***************  *      *     *
      8          *    *       *
      8          *  *         *
      8          **           *
      8          *  *         *
      8          *    *       *
      8          *      *     *
      8          *        *   ***********    -----Theme By Kieran(http://go.kieran.top)
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN" lang="zh-CN">
<!--<![endif]-->

<head>
  <title>一宿更名_BLOG</title>
  <!-- Meta data -->
    <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" >
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="generator" content="一宿更名_BLOG">
    <meta name="author" content="盛祥玉">
    <meta name="description" content="" />
    <meta name="keywords" content="" />

    <!-- Favicon, (keep icon in root folder) -->
    <link rel="Shortcut Icon" href="/img/favicon.ico" type="image/ico">

    <link rel="alternate" href="/atom.xml" title="一宿更名_BLOG" type="application/atom+xml">
    <link rel="stylesheet" href="/css/all.css" media="screen" type="text/css">
    
    <link rel="stylesheet" href="/highlightjs/vs.css" type="text/css">
    

    <!--[if IE 8]>
    <link rel="stylesheet" type="text/css" href="/css/ie8.css" />
    <![endif]-->

    <!-- jQuery | Load our jQuery, with an alternative source fallback to a local version if request is unavailable -->
    <script src="/js/jquery-1.11.1.min.js"></script>
    <script>window.jQuery || document.write('<script src="js/jquery-1.11.1.min.js"><\/script>')</script>

    <!-- Load these in the <head> for quicker IE8+ load times -->
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="/js/html5shiv.min.js"></script>
    <script src="/js/respond.min.js"></script>
    <![endif]-->

  
  
  

  <style>.col-md-8.col-md-offset-2.opening-statement img{display:none;}</style>
</head>

<!--
<body class="post-template">
-->
<body id="index" class="lightnav animsition">

      <!-- ============================ Off-canvas navigation =========================== -->

    <div class="sb-slidebar sb-right sb-style-overlay sb-momentum-scrolling">
        <div class="sb-close" aria-label="Close Menu" aria-hidden="true">
            <img src="/img/close.png" alt="Close"/>
        </div>
        <!-- Lists in Slidebars -->
        <ul class="sb-menu">
            <li><a href="/" class="animsition-link" title="Home">Home</a></li>
            <li><a href="/archives" class="animsition-link" title="archive">archives</a></li>
            <!-- Dropdown Menu -->
			 
            <li>
                <a class="sb-toggle-submenu">Works<span class="sb-caret"></span></a>
                <ul class="sb-submenu">
                    
                        <li><a href="/" target="_BLANK" class="animsition-link">AAA</a></li>
                    
                        <li><a href="/atom.xml" target="_BLANK" class="animsition-link">BBB</a></li>
                    
                </ul>
            </li>
            
            
        	<li>
        		<a class="sb-toggle-submenu">Categories<span class="sb-caret"></span></a>
            	<ul class="sb-submenu">
				  	
				    <li><a href="/categories/1-Css/" class="animsition-link">1-Css<small>(11)</small></a></li>
				    
				    <li><a href="/categories/1-JavaScript/" class="animsition-link">1-JavaScript<small>(14)</small></a></li>
				    
				    <li><a href="/categories/1-TypeScript/" class="animsition-link">1-TypeScript<small>(3)</small></a></li>
				    
				    <li><a href="/categories/2-React/" class="animsition-link">2-React<small>(10)</small></a></li>
				    
				    <li><a href="/categories/2-React-Hooks/" class="animsition-link">2-React_Hooks<small>(5)</small></a></li>
				    
				    <li><a href="/categories/2-Redux和Router/" class="animsition-link">2-Redux和Router<small>(9)</small></a></li>
				    
				    <li><a href="/categories/2-Vue/" class="animsition-link">2-Vue<small>(12)</small></a></li>
				    
				    <li><a href="/categories/3-Brower/" class="animsition-link">3-Brower<small>(30)</small></a></li>
				    
				    <li><a href="/categories/4-Node/" class="animsition-link">4-Node<small>(1)</small></a></li>
				    
				    <li><a href="/categories/4-Promise/" class="animsition-link">4-Promise<small>(7)</small></a></li>
				    
				    <li><a href="/categories/4-Webpack/" class="animsition-link">4-Webpack<small>(8)</small></a></li>
				    
				    <li><a href="/categories/业务和思想/" class="animsition-link">业务和思想<small>(15)</small></a></li>
				    
				    <li><a href="/categories/前端大项/" class="animsition-link">前端大项<small>(9)</small></a></li>
				    
				    <li><a href="/categories/基础补充/" class="animsition-link">基础补充<small>(5)</small></a></li>
				    
				    <li><a href="/categories/框架差异/" class="animsition-link">框架差异<small>(8)</small></a></li>
				    
				    <li><a href="/categories/算法相关/" class="animsition-link">算法相关<small>(10)</small></a></li>
				    
				    <li><a href="/categories/超脱领悟/" class="animsition-link">超脱领悟<small>(9)</small></a></li>
				    
				    <li><a href="/categories/面试复盘/" class="animsition-link">面试复盘<small>(1)</small></a></li>
				    
				</ul>
        	</li>
			
            
            <li>
                <a class="sb-toggle-submenu">Links<span class="sb-caret"></span></a>
                <ul class="sb-submenu">
                    
                    <li><a target="_blank" rel="noopener" href="http://go.kieran.top/" class="animsition-link">Kieran</a></li>
                    
                    <li><a target="_blank" rel="noopener" href="http://domain.com/" class="animsition-link">Name</a></li>
                    
                </ul>
            </li>
            
        </ul>
        <!-- Lists in Slidebars -->
        <ul class="sb-menu secondary">
            
            <li><a href="/about.html" class="animsition-link" title="about">About</a></li>
            <li><a href="/atom.xml" class="animsition-link" title="rss">RSS</a></li>
        </ul>
    </div>
    
    <!-- ============================ END Off-canvas navigation =========================== -->

    <!-- ============================ #sb-site Main Page Wrapper =========================== -->

    <div id="sb-site">
        <!-- #sb-site - All page content should be contained within this id, except the off-canvas navigation itself -->

        <!-- ============================ Header & Logo bar =========================== -->

        <div id="navigation" class="navbar navbar-fixed-top">
            <div class="navbar-inner">
                <div class="container">
                    <!-- Nav logo -->
                    <div class="logo">
                        <a href="/" title="Logo" class="animsition-link">
                         <img src="/img/logo.png" alt="Logo" width="35px;"/> 
                        </a>
                    </div>
                    <!-- // Nav logo -->
                    <!-- Info-bar -->
                    <nav>
                        <ul class="nav">
                            <li><a href="/" class="animsition-link">一宿更名_BLOG</a></li>
                            <li class="nolink"><span>Always </span>Creative.</li>
                            
                            <li><a href="https://github.com/Yxgm" title="Github" target="_blank"><i class="icon-github"></i></a></li>
                            
                            
                            
                            
                            
                            <li class="nolink"><span>Welcome!</span></li>
                        </ul>
                    </nav>
                    <!--// Info-bar -->
                </div>
                <!-- // .container -->
                <div class="learnmore sb-toggle-right">More</div>
                <button type="button" class="navbar-toggle menu-icon sb-toggle-right" title="More">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar before"></span>
                <span class="icon-bar main"></span>
                <span class="icon-bar after"></span>
                </button>
            </div>
            <!-- // .navbar-inner -->
        </div>

        <!-- ============================ Header & Logo bar =========================== -->


      
<section id="intro">
    <div class="container">
        <div class="row col-md-offset-2">
            <div class="col-md-8">
    			<span class="post-meta">
      <time datetime="2022-03-14T03:00:17.466Z" itemprop="datePublished">
          2022-03-14
      </time>
    
</span>
                <h1></h1>
            </div>
        </div>
        <div class="col-md-8 col-md-offset-2">
      		<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>每个fiber节点在更新时都会经历两个阶段：beginWork和completeWork。在Diff之后（详见<a target="_blank" rel="noopener" href="https://github.com/neroneroffy/react-source-code-debug/blob/master/docs/render%E9%98%B6%E6%AE%B5/beginWork%E9%98%B6%E6%AE%B5/Diff%E7%AE%97%E6%B3%95.md">深入理解Diff算法</a> ），workInProgress节点就会进入complete阶段。这个时候拿到的workInProgress节点都是经过diff算法调和过的，也就意味着对于某个节点来说它fiber的形态已经基本确定了，但除此之外还有两点：</p>
<ul>
<li>目前只有fiber形态变了，对于原生DOM组件（HostComponent）和文本节点（HostText）的fiber来说，对应的DOM节点（fiber.stateNode）并未变化。</li>
<li>经过Diff生成的新的workInProgress节点持有了flag(即effectTag)</li>
</ul>
<p>基于这两个特点，completeWork的工作主要有：</p>
<ul>
<li>构建或更新DOM节点，<ul>
<li>构建过程中，会自下而上将子节点的第一层第一层插入到当前节点。</li>
<li>更新过程中，会计算DOM节点的属性，一旦属性需要更新，会为DOM节点对应的workInProgress节点标记Update的effectTag。</li>
</ul>
</li>
<li>自下而上收集effectList，最终收集到root上</li>
</ul>
<p>对于正常执行工作的workInProgress节点来说，会走以上的流程。但是免不了节点的更新会出错，所以对出错的节点会采取措施，这涉及到错误边界以及Suspense的概念，<br>本文只做简单流程分析。</p>
<p>这一节涉及的知识点有</p>
<ul>
<li>DOM节点的创建以及挂载</li>
<li>DOM属性的处理</li>
<li>effectList的收集</li>
<li>错误处理</li>
</ul>
<h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><p>completeUnitOfWork是completeWork阶段的入口。它内部有一个循环，会自下而上地遍历workInProgress节点，依次处理节点。</p>
<p>对于正常的workInProgress节点，会执行completeWork。这其中会对HostComponent组件完成更新props、绑定事件等DOM相关的工作。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">completeUnitOfWork</span>(<span class="params">unitOfWork: Fiber</span>): <span class="keyword">void</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> completedWork = unitOfWork;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> current = completedWork.<span class="property">alternate</span>;</span><br><span class="line">    <span class="keyword">const</span> returnFiber = completedWork.<span class="property">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((completedWork.<span class="property">effectTag</span> &amp; <span class="title class_">Incomplete</span>) === <span class="title class_">NoEffect</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果workInProgress节点没有出错，走正常的complete流程</span></span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> next;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 省略了判断逻辑</span></span><br><span class="line">      <span class="comment">// 对节点进行completeWork，生成DOM，更新props，绑定事件</span></span><br><span class="line">      next = <span class="title function_">completeWork</span>(current, completedWork, subtreeRenderLanes);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (next !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 任务被挂起的情况，</span></span><br><span class="line">        workInProgress = next;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 收集workInProgress节点的lanes，不漏掉被跳过的update的lanes，便于再次发起调度</span></span><br><span class="line">      <span class="title function_">resetChildLanes</span>(completedWork);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将当前节点的effectList并入父级节点</span></span><br><span class="line">       ...</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果当前节点他自己也有effectTag，将它自己</span></span><br><span class="line">      <span class="comment">// 也并入到父级节点的effectList</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 执行到这个分支说明之前的更新有错误</span></span><br><span class="line">      <span class="comment">// 进入unwindWork</span></span><br><span class="line">      <span class="keyword">const</span> next = <span class="title function_">unwindWork</span>(completedWork, subtreeRenderLanes);</span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找兄弟节点，若有则进行beginWork -&gt; completeWork</span></span><br><span class="line">    <span class="keyword">const</span> siblingFiber = completedWork.<span class="property">sibling</span>;</span><br><span class="line">    <span class="keyword">if</span> (siblingFiber !== <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">      workInProgress = siblingFiber;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若没有兄弟节点，那么向上回到父级节点</span></span><br><span class="line">    <span class="comment">// 父节点进入complete</span></span><br><span class="line">    completedWork = returnFiber;</span><br><span class="line">    <span class="comment">// 将workInProgress节点指向父级节点</span></span><br><span class="line">    workInProgress = completedWork;</span><br><span class="line">  &#125; <span class="keyword">while</span> (completedWork !== <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 到达了root，整棵树完成了工作，标记完成状态</span></span><br><span class="line">  <span class="keyword">if</span> (workInProgressRootExitStatus === <span class="title class_">RootIncomplete</span>) &#123;</span><br><span class="line">    workInProgressRootExitStatus = <span class="title class_">RootCompleted</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由于React的大部分的fiber节点最终都要体现为DOM，所以本文主要分析HostComponent相关的处理流程。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">completeWork</span>(<span class="params"></span></span><br><span class="line"><span class="params">  current: Fiber | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  workInProgress: Fiber,</span></span><br><span class="line"><span class="params">  renderLanes: Lanes,</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Fiber</span> | <span class="literal">null</span> &#123;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (workInProgress.<span class="property">tag</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">HostComponent</span>: &#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">if</span> (current !== <span class="literal">null</span> &amp;&amp; workInProgress.<span class="property">stateNode</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 更新</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 创建</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">HostText</span>: &#123;</span><br><span class="line">      <span class="keyword">const</span> newText = newProps;</span><br><span class="line">      <span class="keyword">if</span> (current &amp;&amp; workInProgress.<span class="property">stateNode</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 更新</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 创建</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">SuspenseComponent</span>:</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由completeWork的结构可以看出，就是依据fiber的tag做不同处理。对HostComponent 和 HostText的处理是类似的，都是针对它们的DOM节点，处理方法又会分为更新和创建。</p>
<p>若current存在并且workInProgress.stateNode（workInProgress节点对应的DOM实例）存在，说明此workInProgress节点的DOM节点已经存在，走更新逻辑，否则进行创建。</p>
<p>DOM节点的更新实则是属性的更新，会在下面的<code>DOM属性的处理 -&gt; 属性的更新</code>中讲到，先来看一下DOM节点的创建和插入。</p>
<h1 id="DOM节点的创建和插入"><a href="#DOM节点的创建和插入" class="headerlink" title="DOM节点的创建和插入"></a>DOM节点的创建和插入</h1><p>我们知道，此时的completeWork处理的是经过diff算法之后产生的新fiber。对于HostComponent类型的新fiber来说，它可能有DOM节点，也可能没有。没有的话，就需要执行先创建，再插入的操作，由此引入DOM的插入算法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (current !== <span class="literal">null</span> &amp;&amp; workInProgress.<span class="property">stateNode</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 表明fiber有dom节点，需要执行更新过程</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// fiber不存在DOM节点</span></span><br><span class="line">    <span class="comment">// 先创建DOM节点</span></span><br><span class="line">    <span class="keyword">const</span> instance = <span class="title function_">createInstance</span>(</span><br><span class="line">      type,</span><br><span class="line">      newProps,</span><br><span class="line">      rootContainerInstance,</span><br><span class="line">      currentHostContext,</span><br><span class="line">      workInProgress,</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//DOM节点插入</span></span><br><span class="line">    <span class="title function_">appendAllChildren</span>(instance, workInProgress, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将DOM节点挂载到fiber的stateNode上</span></span><br><span class="line">    workInProgress.<span class="property">stateNode</span> = instance;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>需要注意的是，DOM的插入并不是将当前DOM插入它的父节点，而是将当前这个DOM节点的第一层子节点插入到它自己的下面。</strong></p>
<h2 id="图解算法"><a href="#图解算法" class="headerlink" title="图解算法"></a>图解算法</h2><p>此时的completeWork阶段，会自下而上遍历workInProgress树到root，每经过一层都会按照上面的规则插入DOM。下边用一个例子来理解一下这个过程。</p>
<p>这是一棵fiber树的结构，workInProgress树最终要成为这个形态。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1              App</span><br><span class="line">                |</span><br><span class="line">                |</span><br><span class="line">2              div</span><br><span class="line">              /</span><br><span class="line">             /</span><br><span class="line">3        &lt;List/&gt;---&gt;span</span><br><span class="line">          /</span><br><span class="line">         /</span><br><span class="line">4       p ----&gt; &#x27;text node&#x27;</span><br><span class="line">       /</span><br><span class="line">      /</span><br><span class="line">5    h1</span><br></pre></td></tr></table></figure>
<p>构建workInProgress树的DFS遍历对沿途节点一路beginWork，此时已经遍历到最深的h1节点，它的beginWork已经结束，开始进入completeWork阶段，此时所在的层级深度为第5层。</p>
<p><strong>第5层</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1              App</span><br><span class="line">                |</span><br><span class="line">                |</span><br><span class="line">2              div</span><br><span class="line">              /</span><br><span class="line">             /</span><br><span class="line">3        &lt;List/&gt;</span><br><span class="line">          /</span><br><span class="line">         /</span><br><span class="line">4       p</span><br><span class="line">       /</span><br><span class="line">      /</span><br><span class="line">5---&gt;h1</span><br></pre></td></tr></table></figure>

<p>此时workInProgress节点指向h1的fiber，它对应的dom节点为h1，dom标签创建出来以后进入<code>appendAllChildren</code>，因为当前的workInProgress节点为h1，所以它的child为null，无子节点可插入，退出。</p>
<p>h1节点完成工作往上返回到第4层的p节点。</p>
<p>此时的dom树为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h1</span><br></pre></td></tr></table></figure>

<p><strong>第4层</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1              App</span><br><span class="line">                |</span><br><span class="line">                |</span><br><span class="line">2              div</span><br><span class="line">              /</span><br><span class="line">             /</span><br><span class="line">3        &lt;List/&gt;</span><br><span class="line">          /</span><br><span class="line">         /</span><br><span class="line">4 ---&gt;  p ----&gt; &#x27;text node&#x27;</span><br><span class="line">       /</span><br><span class="line">      /</span><br><span class="line">5    h1</span><br></pre></td></tr></table></figure>

<p>此时workInProgress节点指向p的fiber，它对应的dom节点为p，进入<code>appendAllChildren</code>，发现 p 的child为 h1，并且是HostComponent组件，将 h1 插入 p，然后寻找子节点h1是否有同级的sibling节点。<br>发现没有，退出。</p>
<p>p节点的所有工作完成，它的兄弟节点：HostText类型的组件’text’会作为下一个工作单元，执行beginWork再进入completeWork。现在需要对它执行<code>appendAllChildren</code>，发现没有child，不执行插入操作。它的工作也完成，return到父节点<code>&lt;List/&gt;</code>，进入第3层</p>
<p>此时的dom树为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   p      &#x27;text&#x27;</span><br><span class="line">  /</span><br><span class="line"> /</span><br><span class="line">h1</span><br></pre></td></tr></table></figure>

<p><strong>第3层</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1              App</span><br><span class="line">                |</span><br><span class="line">                |</span><br><span class="line">2              div</span><br><span class="line">              /</span><br><span class="line">             /</span><br><span class="line">3 ---&gt;   &lt;List/&gt;---&gt;span</span><br><span class="line">          /</span><br><span class="line">         /</span><br><span class="line">4       p ----&gt; &#x27;text&#x27;</span><br><span class="line">       /</span><br><span class="line">      /</span><br><span class="line">5    h1</span><br></pre></td></tr></table></figure>


<p>此时workInProgress节点指向<code>&lt;List/&gt;</code>的fiber，对它进行completeWork，由于此时它是自定义组件，不属于HostComponent，所以不会对它进行子节点的插入操作。</p>
<p>寻找它的兄弟节点span，对span先进行beginWork再进行到completeWork，执行span子节点的插入操作，发现它没有child，退出。return到父节点div，进入第二层。</p>
<p>此时的dom树为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">           span</span><br><span class="line"></span><br><span class="line">   p      &#x27;text&#x27;</span><br><span class="line">  /</span><br><span class="line"> /</span><br><span class="line">h1</span><br></pre></td></tr></table></figure>

<p><strong>第2层</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1              App</span><br><span class="line">                |</span><br><span class="line">                |</span><br><span class="line">2 ---------&gt;   div</span><br><span class="line">              /</span><br><span class="line">             /</span><br><span class="line">3        &lt;List/&gt;---&gt;span</span><br><span class="line">          /</span><br><span class="line">         /</span><br><span class="line">4       p ----&gt;&#x27;text&#x27;</span><br><span class="line">       /</span><br><span class="line">      /</span><br><span class="line">5    h1</span><br></pre></td></tr></table></figure>
<p>此时workInProgress节点指向div的fiber，对它进行completeWork，执行div的子节点插入。由于它的child是<List/>，不满足<code>node.tag === HostComponent || node.tag === HostText</code>的条件，所以不会将它插入到div中。继续向下找<List/>的child，发现是p，将P插入div，然后寻找p的sibling，发现了’text’，将它也插入div。之后再也找不到同级节点，此时回到第三层的<List/>节点。</p>
<p><List/>有sibling节点span，将span插入到div。由于span没有子节点，退出。</p>
<p>此时的dom树为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">         div</span><br><span class="line">      /   |   \</span><br><span class="line">     /    |    \</span><br><span class="line">   p   &#x27;text&#x27;  span</span><br><span class="line">  /</span><br><span class="line"> /</span><br><span class="line">h1</span><br></pre></td></tr></table></figure>

<p><strong>第1层</strong><br>此时workInProgress节点指向App的fiber，由于它是自定义节点，所以不会对它进行子节点的插入操作。</p>
<p>到此为止，dom树基本构建完成。在这个过程中我们可以总结出几个规律：</p>
<ol>
<li><p>向节点中插入dom节点时，只插入它子节点中第一层的dom。可以把这个插入可以看成是一个自下而上收集dom节点的过程。第一层子节点之下的dom，已经在第一层子节点执行插入时被插入第一层子节点了，从下往上逐层completeWork<br>的这个过程类似于dom节点的累加。</p>
</li>
<li><p>总是优先看本身可否插入，再往下找，之后才是找sibling节点。</p>
</li>
</ol>
<p>这是由于fiber树和dom树的差异导致，每个fiber节点不一定对应一个dom节点，但一个dom节点一定对应一个fiber节点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> fiber树      DOM树</span><br><span class="line"></span><br><span class="line"> &lt;App/&gt;       div</span><br><span class="line">   |           |</span><br><span class="line">  div        input</span><br><span class="line">   |</span><br><span class="line">&lt;Input/&gt;</span><br><span class="line">   |</span><br><span class="line"> input</span><br></pre></td></tr></table></figure>
<p>由于一个原生DOM组件的子组件有可能是类组件或函数组件，所以会优先检查自身，发现自己不是原生DOM组件，不能被插入到父级fiber节点对应的DOM中，所以要往下找，直到找到原生DOM组件，执行插入，最后再从这一层找同级的fiber节点，同级节点也会执行<code>先自检，再检查下级，再检查下级的同级</code>的操作。</p>
<p>可以看出，节点的插入也是深度优先。值得注意的是，这一整个插入的流程并没有真的将DOM插入到真实的页面上，它只是在操作fiber上的stateNode。真实的插入DOM操作发生在commit阶段。</p>
<h2 id="节点插入源码"><a href="#节点插入源码" class="headerlink" title="节点插入源码"></a>节点插入源码</h2><p>下面是插入节点算法的源码，可以对照上面的过程来看。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">appendAllChildren = <span class="keyword">function</span>(<span class="params"></span></span><br><span class="line"><span class="params">  parent: Instance,</span></span><br><span class="line"><span class="params">  workInProgress: Fiber,</span></span><br><span class="line"><span class="params">  needsVisibilityToggle: boolean,</span></span><br><span class="line"><span class="params">  isHidden: boolean,</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 找到当前节点的子fiber节点</span></span><br><span class="line">  <span class="keyword">let</span> node = workInProgress.<span class="property">child</span>;</span><br><span class="line">  <span class="comment">// 当存在子节点时，去往下遍历</span></span><br><span class="line">  <span class="keyword">while</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node.<span class="property">tag</span> === <span class="title class_">HostComponent</span> || node.<span class="property">tag</span> === <span class="title class_">HostText</span>) &#123;</span><br><span class="line">      <span class="comment">// 子节点是原生DOM 节点，直接可以插入</span></span><br><span class="line">      <span class="title function_">appendInitialChild</span>(parent, node.<span class="property">stateNode</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (enableFundamentalAPI &amp;&amp; node.<span class="property">tag</span> === <span class="title class_">FundamentalComponent</span>) &#123;</span><br><span class="line">      <span class="title function_">appendInitialChild</span>(parent, node.<span class="property">stateNode</span>.<span class="property">instance</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.<span class="property">tag</span> === <span class="title class_">HostPortal</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果是HostPortal类型的节点，什么都不做</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.<span class="property">child</span> !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 代码执行到这，说明node不符合插入要求，</span></span><br><span class="line">      <span class="comment">// 继续寻找子节点</span></span><br><span class="line">      node.<span class="property">child</span>.<span class="property">return</span> = node;</span><br><span class="line">      node = node.<span class="property">child</span>;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node === workInProgress) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当不存在兄弟节点时往上找，此过程发生在当前completeWork节点的子节点再无子节点的场景，</span></span><br><span class="line">    <span class="comment">// 并不是直接从当前completeWork的节点去往上找</span></span><br><span class="line">    <span class="keyword">while</span> (node.<span class="property">sibling</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (node.<span class="property">return</span> === <span class="literal">null</span> || node.<span class="property">return</span> === workInProgress) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      node = node.<span class="property">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当不存在子节点时，从sibling节点入手开始找</span></span><br><span class="line">    node.<span class="property">sibling</span>.<span class="property">return</span> = node.<span class="property">return</span>;</span><br><span class="line">    node = node.<span class="property">sibling</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="DOM属性的处理"><a href="#DOM属性的处理" class="headerlink" title="DOM属性的处理"></a>DOM属性的处理</h1><p>上面的插入过程完成了DOM树的构建，这之后要做的就是为每个DOM节点计算它自己的属性（props）。由于节点存在创建和更新两种情况，所以对属性的处理也会区别对待。</p>
<h2 id="属性的创建"><a href="#属性的创建" class="headerlink" title="属性的创建"></a>属性的创建</h2><p>属性的创建相对更新来说比较简单，这个过程发生在DOM节点构建的最后，调用<code>finalizeInitialChildren</code>函数完成新节点的属性设置。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (current !== <span class="literal">null</span> &amp;&amp; workInProgress.<span class="property">stateNode</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 更新</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 创建、插入DOM节点的过程</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// DOM节点属性的初始化</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      <span class="title function_">finalizeInitialChildren</span>(</span><br><span class="line">        instance,</span><br><span class="line">        type,</span><br><span class="line">        newProps,</span><br><span class="line">        rootContainerInstance,</span><br><span class="line">        currentHostContext,</span><br><span class="line">      )</span><br><span class="line">     ) &#123;</span><br><span class="line">       <span class="comment">// 最终会依据textarea的autoFocus属性</span></span><br><span class="line">       <span class="comment">// 来决定是否更新fiber</span></span><br><span class="line">       <span class="title function_">markUpdate</span>(workInProgress);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>finalizeInitialChildren</code>最终会调用<code>setInitialProperties</code>，来完成属性的设置。这个过程好理解，主要就是调用<code>setInitialDOMProperties</code>将属性直接设置进DOM节点（事件在这个阶段绑定）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">setInitialDOMProperties</span>(<span class="params"></span></span><br><span class="line"><span class="params">  tag: string,</span></span><br><span class="line"><span class="params">  domElement: Element,</span></span><br><span class="line"><span class="params">  rootContainerElement: Element | Document,</span></span><br><span class="line"><span class="params">  nextProps: <span class="built_in">Object</span>,</span></span><br><span class="line"><span class="params">  isCustomComponentTag: boolean,</span></span><br><span class="line"><span class="params"></span>): <span class="keyword">void</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> propKey <span class="keyword">in</span> nextProps) &#123;</span><br><span class="line">    <span class="keyword">const</span> nextProp = nextProps[propKey];</span><br><span class="line">    <span class="keyword">if</span> (propKey === <span class="variable constant_">STYLE</span>) &#123;</span><br><span class="line">      <span class="comment">// 设置行内样式</span></span><br><span class="line">      <span class="title function_">setValueForStyles</span>(domElement, nextProp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propKey === <span class="variable constant_">DANGEROUSLY_SET_INNER_HTML</span>) &#123;</span><br><span class="line">      <span class="comment">// 设置innerHTML</span></span><br><span class="line">      <span class="keyword">const</span> nextHtml = nextProp ? nextProp[<span class="variable constant_">HTML</span>] : <span class="literal">undefined</span>;</span><br><span class="line">      <span class="keyword">if</span> (nextHtml != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="title function_">setInnerHTML</span>(domElement, nextHtml);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     ...</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (registrationNameDependencies.<span class="title function_">hasOwnProperty</span>(propKey)) &#123;</span><br><span class="line">      <span class="comment">// 绑定事件</span></span><br><span class="line">      <span class="keyword">if</span> (nextProp != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="title function_">ensureListeningTo</span>(rootContainerElement, propKey);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nextProp != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 设置其余属性</span></span><br><span class="line">      <span class="title function_">setValueForProperty</span>(domElement, propKey, nextProp, isCustomComponentTag);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="属性的更新"><a href="#属性的更新" class="headerlink" title="属性的更新"></a>属性的更新</h2><p>若对已有DOM节点进行更新，说明只对属性进行更新即可，因为节点已经存在，不存在删除和新增的情况。<code>updateHostComponent</code>函数负责HostComponent对应DOM节点属性的更新，代码不多很好理解。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">updateHostComponent = function(</span><br><span class="line">  current: Fiber,</span><br><span class="line">  workInProgress: Fiber,</span><br><span class="line">  type: Type,</span><br><span class="line">  newProps: Props,</span><br><span class="line">  rootContainerInstance: Container,</span><br><span class="line">) &#123;</span><br><span class="line">  const oldProps = current.memoizedProps;</span><br><span class="line">  // 新旧props相同，不更新</span><br><span class="line">  if (oldProps === newProps) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const instance: Instance = workInProgress.stateNode;</span><br><span class="line">  const currentHostContext = getHostContext();</span><br><span class="line"></span><br><span class="line">  // prepareUpdate计算新属性</span><br><span class="line">  const updatePayload = prepareUpdate(</span><br><span class="line">    instance,</span><br><span class="line">    type,</span><br><span class="line">    oldProps,</span><br><span class="line">    newProps,</span><br><span class="line">    rootContainerInstance,</span><br><span class="line">    currentHostContext,</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  // 最终新属性被挂载到updateQueue中，供commit阶段使用</span><br><span class="line">  workInProgress.updateQueue = (updatePayload: any);</span><br><span class="line"></span><br><span class="line">  if (updatePayload) &#123;</span><br><span class="line">    // 标记workInProgress节点有更新</span><br><span class="line">    markUpdate(workInProgress);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看出它只做了一件事，就是计算新的属性，并挂载到workInProgress节点的updateQueue中，它的形式是以2为单位，index为偶数的是key，为奇数的是value：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ &#x27;style&#x27;, &#123; color: &#x27;blue&#x27; &#125;, title, &#x27;测试标题&#x27; ]</span><br></pre></td></tr></table></figure>
<p>这个结果由<code>diffProperties</code>计算产生，它对比lastProps和nextProps，计算出updatePayload。</p>
<p>举个例子来说，有如下组件，div上绑定的点击事件会改变它的props。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PropsDiff</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&#x27;更新前的标题&#x27;</span>,</span><br><span class="line">        <span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">        <span class="attr">fontSize</span>: <span class="number">18</span></span><br><span class="line">    &#125;</span><br><span class="line">    onClickDiv = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">            <span class="attr">title</span>: <span class="string">&#x27;更新后的标题&#x27;</span>,</span><br><span class="line">            <span class="attr">color</span>: <span class="string">&#x27;blue&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; color, fontSize, title &#125; = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">className</span>=<span class="string">&quot;test&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">onClick</span>=<span class="string">&#123;this.onClickDiv&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">title</span>=<span class="string">&#123;title&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">style</span>=<span class="string">&#123;&#123;color,</span> <span class="attr">fontSize</span>&#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            &#123;<span class="attr">...this.state.color</span> === <span class="string">&#x27;red&#x27;</span> &amp;&amp; &#123; <span class="attr">props:</span> &#x27;自定义旧属性&#x27; &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        &gt;</span></span></span><br><span class="line"><span class="language-xml">            测试div的Props变化</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>lastProps和nextProps分别为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">lastProps</span><br><span class="line">&#123;</span><br><span class="line">  &quot;className&quot;: &quot;test&quot;,</span><br><span class="line">  &quot;title&quot;: &quot;更新前的标题&quot;,</span><br><span class="line">  &quot;style&quot;: &#123; &quot;color&quot;: &quot;red&quot;, &quot;fontSize&quot;: 18&#125;,</span><br><span class="line">  &quot;props&quot;: &quot;自定义旧属性&quot;,</span><br><span class="line">  &quot;children&quot;: &quot;测试div的Props变化&quot;,</span><br><span class="line">  &quot;onClick&quot;: () =&gt; &#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nextProps</span><br><span class="line">&#123;</span><br><span class="line">  &quot;className&quot;: &quot;test&quot;,</span><br><span class="line">  &quot;title&quot;: &quot;更新后的标题&quot;,</span><br><span class="line">  &quot;style&quot;: &#123; &quot;color&quot;:&quot;blue&quot;, &quot;fontSize&quot;:18 &#125;,</span><br><span class="line">  &quot;children&quot;: &quot;测试div的Props变化&quot;,</span><br><span class="line">  &quot;onClick&quot;: () =&gt; &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它们有变化的是propsKey是<code>style、title、props</code>，经过diff，最终打印出来的updatePayload为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">   &quot;props&quot;, null,</span><br><span class="line">   &quot;title&quot;, &quot;更新后的标题&quot;,</span><br><span class="line">   &quot;style&quot;, &#123;&quot;color&quot;:&quot;blue&quot;&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><code>diffProperties</code>内部的规则可以概括为：</p>
<p>若有某个属性（propKey），它在</p>
<ul>
<li>lastProps中存在，nextProps中不存在，将propKey的value标记为null表示删除</li>
<li>lastProps中不存在，nextProps中存在，将nextProps中的propKey和对应的value添加到updatePayload</li>
<li>lastProps中存在，nextProps中也存在，将nextProps中的propKey和对应的value添加到updatePayload</li>
</ul>
<p>对照这个规则看一下源码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">diffProperties</span>(<span class="params"></span></span><br><span class="line"><span class="params">  domElement: Element,</span></span><br><span class="line"><span class="params">  tag: string,</span></span><br><span class="line"><span class="params">  lastRawProps: <span class="built_in">Object</span>,</span></span><br><span class="line"><span class="params">  nextRawProps: <span class="built_in">Object</span>,</span></span><br><span class="line"><span class="params">  rootContainerElement: Element | Document,</span></span><br><span class="line"><span class="params"></span>): <span class="literal">null</span> | <span class="title class_">Array</span>&lt;mixed&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> <span class="attr">updatePayload</span>: <span class="literal">null</span> | <span class="title class_">Array</span>&lt;any&gt; = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> <span class="attr">lastProps</span>: <span class="title class_">Object</span>;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">nextProps</span>: <span class="title class_">Object</span>;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> propKey;</span><br><span class="line">  <span class="keyword">let</span> styleName;</span><br><span class="line">  <span class="keyword">let</span> styleUpdates = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (propKey <span class="keyword">in</span> lastProps) &#123;</span><br><span class="line">    <span class="comment">// 循环lastProps，找出需要标记删除的propKey</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      nextProps.<span class="title function_">hasOwnProperty</span>(propKey) ||</span><br><span class="line">      !lastProps.<span class="title function_">hasOwnProperty</span>(propKey) ||</span><br><span class="line">      lastProps[propKey] == <span class="literal">null</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// 对propKey来说，如果nextProps也有，或者lastProps没有，那么</span></span><br><span class="line">      <span class="comment">// 就不需要标记为删除，跳出本次循环继续判断下一个propKey</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (propKey === <span class="variable constant_">STYLE</span>) &#123;</span><br><span class="line">      <span class="comment">// 删除style</span></span><br><span class="line">      <span class="keyword">const</span> lastStyle = lastProps[propKey];</span><br><span class="line">      <span class="keyword">for</span> (styleName <span class="keyword">in</span> lastStyle) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lastStyle.<span class="title function_">hasOwnProperty</span>(styleName)) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!styleUpdates) &#123;</span><br><span class="line">            styleUpdates = &#123;&#125;;</span><br><span class="line">          &#125;</span><br><span class="line">          styleUpdates[styleName] = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="comment">/*...*/</span>) &#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">// 一些特定种类的propKey的删除</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 将其他种类的propKey标记为删除</span></span><br><span class="line">      (updatePayload = updatePayload || []).<span class="title function_">push</span>(propKey, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (propKey <span class="keyword">in</span> nextProps) &#123;</span><br><span class="line">    <span class="comment">// 将新prop添加到updatePayload</span></span><br><span class="line">    <span class="keyword">const</span> nextProp = nextProps[propKey];</span><br><span class="line">    <span class="keyword">const</span> lastProp = lastProps != <span class="literal">null</span> ? lastProps[propKey] : <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      !nextProps.<span class="title function_">hasOwnProperty</span>(propKey) ||</span><br><span class="line">      nextProp === lastProp ||</span><br><span class="line">      (nextProp == <span class="literal">null</span> &amp;&amp; lastProp == <span class="literal">null</span>)</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// 如果nextProps不存在propKey，或者前后的value相同，或者前后的value都为null</span></span><br><span class="line">      <span class="comment">// 那么不需要添加进去，跳出本次循环继续处理下一个prop</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (propKey === <span class="variable constant_">STYLE</span>) &#123;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      * lastProp: &#123; color: &#x27;red&#x27; &#125;</span></span><br><span class="line"><span class="comment">      * nextProp: &#123; color: &#x27;blue&#x27; &#125;</span></span><br><span class="line"><span class="comment">      * */</span></span><br><span class="line">      <span class="comment">// 如果style在lastProps和nextProps中都有</span></span><br><span class="line">      <span class="comment">// 那么需要删除lastProps中style的样式</span></span><br><span class="line">      <span class="keyword">if</span> (lastProp) &#123;</span><br><span class="line">        <span class="comment">// 如果lastProps中也有style</span></span><br><span class="line">        <span class="comment">// 将style内的样式属性设置为空</span></span><br><span class="line">        <span class="comment">// styleUpdates = &#123; color: &#x27;&#x27; &#125;</span></span><br><span class="line">        <span class="keyword">for</span> (styleName <span class="keyword">in</span> lastProp) &#123;</span><br><span class="line">          <span class="keyword">if</span> (</span><br><span class="line">            lastProp.<span class="title function_">hasOwnProperty</span>(styleName) &amp;&amp;</span><br><span class="line">            (!nextProp || !nextProp.<span class="title function_">hasOwnProperty</span>(styleName))</span><br><span class="line">          ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!styleUpdates) &#123;</span><br><span class="line">              styleUpdates = &#123;&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            styleUpdates[styleName] = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 以nextProp的属性名为key设置新的style的value</span></span><br><span class="line">        <span class="comment">// styleUpdates = &#123; color: &#x27;blue&#x27; &#125;</span></span><br><span class="line">        <span class="keyword">for</span> (styleName <span class="keyword">in</span> nextProp) &#123;</span><br><span class="line">          <span class="keyword">if</span> (</span><br><span class="line">            nextProp.<span class="title function_">hasOwnProperty</span>(styleName) &amp;&amp;</span><br><span class="line">            lastProp[styleName] !== nextProp[styleName]</span><br><span class="line">          ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!styleUpdates) &#123;</span><br><span class="line">              styleUpdates = &#123;&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            styleUpdates[styleName] = nextProp[styleName];</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果lastProps中没有style，说明新增的</span></span><br><span class="line">        <span class="comment">// 属性全部可放入updatePayload</span></span><br><span class="line">        <span class="keyword">if</span> (!styleUpdates) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!updatePayload) &#123;</span><br><span class="line">            updatePayload = [];</span><br><span class="line">          &#125;</span><br><span class="line">          updatePayload.<span class="title function_">push</span>(propKey, styleUpdates);</span><br><span class="line">          <span class="comment">// updatePayload: [ style, null ]</span></span><br><span class="line">        &#125;</span><br><span class="line">        styleUpdates = nextProp;</span><br><span class="line">        <span class="comment">// styleUpdates = &#123; color: &#x27;blue&#x27; &#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="comment">/*...*/</span>) &#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">// 一些特定种类的propKey的处理</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (registrationNameDependencies.<span class="title function_">hasOwnProperty</span>(propKey)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nextProp != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 重新绑定事件</span></span><br><span class="line">        <span class="title function_">ensureListeningTo</span>(rootContainerElement, propKey);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!updatePayload &amp;&amp; lastProp !== nextProp) &#123;</span><br><span class="line">        <span class="comment">// 事件重新绑定后，需要赋值updatePayload，使这个节点得以被更新</span></span><br><span class="line">        updatePayload = [];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">      <span class="keyword">typeof</span> nextProp === <span class="string">&#x27;object&#x27;</span> &amp;&amp;</span><br><span class="line">      nextProp !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">      nextProp.<span class="property">$$typeof</span> === <span class="variable constant_">REACT_OPAQUE_ID_TYPE</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// 服务端渲染相关</span></span><br><span class="line">      nextProp.<span class="title function_">toString</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// 将计算好的属性push到updatePayload</span></span><br><span class="line">      (updatePayload = updatePayload || []).<span class="title function_">push</span>(propKey, nextProp);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (styleUpdates) &#123;</span><br><span class="line">    <span class="comment">// 将style和值push进updatePayload</span></span><br><span class="line">    (updatePayload = updatePayload || []).<span class="title function_">push</span>(<span class="variable constant_">STYLE</span>, styleUpdates);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;updatePayload&#x27;</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(updatePayload));</span><br><span class="line">  <span class="comment">// [ &#x27;style&#x27;, &#123; color: &#x27;blue&#x27; &#125;, title, &#x27;测试标题&#x27; ]</span></span><br><span class="line">  <span class="keyword">return</span> updatePayload;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DOM节点属性的diff为workInProgress节点挂载了带有新属性的updateQueue，一旦节点的updateQueue不为空，它就会被标记上Update的effectTag，commit阶段会处理updateQueue。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (updatePayload) &#123;</span><br><span class="line">  <span class="title function_">markUpdate</span>(workInProgress);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="effect链的收集"><a href="#effect链的收集" class="headerlink" title="effect链的收集"></a>effect链的收集</h1><p>经过beginWork和上面对于DOM的操作，有变化的workInProgress节点已经被打上了effectTag。</p>
<p>一旦workInProgress节点持有了effectTag，说明它需要在commit阶段被处理。每个workInProgress节点都有一个firstEffect和lastEffect，是一个单向链表，来表示它自身以及它的子节点上所有持有effectTag的workInProgress节点。completeWork阶段在向上遍历的过程中也会逐层收集effect链，最终收集到root上，供接下来的commit阶段使用。</p>
<p>实现上相对简单，对于某个workInProgress节点来说，先将它已有的effectList并入到父级节点，再判断它自己有没有effectTag，有的话也并入到父级节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">* effectList是一条单向链表，每完成一个工作单元上的任务，</span></span><br><span class="line"><span class="comment">* 都要将它产生的effect链表并入</span></span><br><span class="line"><span class="comment">* 上级工作单元。</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="comment">// 将当前节点的effectList并入到父节点的effectList</span></span><br><span class="line"><span class="keyword">if</span> (returnFiber.<span class="property">firstEffect</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">  returnFiber.<span class="property">firstEffect</span> = completedWork.<span class="property">firstEffect</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (completedWork.<span class="property">lastEffect</span> !== <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (returnFiber.<span class="property">lastEffect</span> !== <span class="literal">null</span>) &#123;</span><br><span class="line">    returnFiber.<span class="property">lastEffect</span>.<span class="property">nextEffect</span> = completedWork.<span class="property">firstEffect</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  returnFiber.<span class="property">lastEffect</span> = completedWork.<span class="property">lastEffect</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将自身添加到effect链，添加时跳过NoWork 和</span></span><br><span class="line"><span class="comment">// PerformedWork的effectTag，因为真正</span></span><br><span class="line"><span class="comment">// 的commit用不到</span></span><br><span class="line"><span class="keyword">const</span> effectTag = completedWork.<span class="property">effectTag</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (effectTag &gt; <span class="title class_">PerformedWork</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (returnFiber.<span class="property">lastEffect</span> !== <span class="literal">null</span>) &#123;</span><br><span class="line">    returnFiber.<span class="property">lastEffect</span>.<span class="property">nextEffect</span> = completedWork;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    returnFiber.<span class="property">firstEffect</span> = completedWork;</span><br><span class="line">  &#125;</span><br><span class="line">  returnFiber.<span class="property">lastEffect</span> = completedWork;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个节点都会执行这样的操作，最终当回到root的时候，root上会有一条完整的effectList，包含了所有需要处理的fiber节点。</p>
<h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><p>completeUnitWork中的错误处理是错误边界机制的组成部分。</p>
<p>错误边界是一种React组件，一旦类组件中使用了<code>getDerivedStateFromError</code>或<code>componentDidCatch</code>，就可以捕获发生在其子树中的错误，那么它就是错误边界。</p>
<p>回到源码中，节点如果在更新的过程中报错，它就会被打上Incomplete的effectTag，说明节点的更新工作未完成，因此不能执行正常的completeWork，要走另一个判断分支进行处理。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((completedWork.<span class="property">effectTag</span> &amp; <span class="title class_">Incomplete</span>) === <span class="title class_">NoEffect</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 有Incomplete的节点会进入到这个判断分支进行错误处理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Incomplete从何而来"><a href="#Incomplete从何而来" class="headerlink" title="Incomplete从何而来"></a>Incomplete从何而来</h2><p>什么情况下节点会被标记上Incomplete呢？这还要从最外层的工作循环说起。</p>
<p>concurrent模式的渲染函数：renderRootConcurrent之中在构建workInProgress树时，使用了try…catch来包裹执行函数，这对处理报错节点提供了机会。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="title function_">workLoopConcurrent</span>();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (thrownValue) &#123;</span><br><span class="line">      <span class="title function_">handleError</span>(root, thrownValue);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>一旦某个节点执行出错，会进入<code>handleError</code>函数处理。该函数中可以获取到当前出错的workInProgress节点，除此之外我们暂且不关注其他功能，只需清楚它调用了<code>throwException</code>。</p>
<p><code>throwException</code>会为这个出错的workInProgress节点打上<code>Incomplete 的 effectTag</code>，表明未完成，在向上找到可以处理错误的节点（即错误边界），添加上ShouldCapture 的 effectTag。</p>
<p>另外，创建代表错误的update，<code>getDerivedStateFromError</code>放入payload，<code>componentDidCatch</code>放入callback。最后这个update入队节点的updateQueue。</p>
<p><code>throwException</code>执行完毕，回到出错的workInProgress节点，执行<code>completeUnitOfWork</code>，目的是将错误终止到当前的节点，因为它本身都出错了，再向下渲染没有意义。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">handleError</span>(<span class="params">root, thrownValue</span>):<span class="keyword">void</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 给当前出错的workInProgress节点添加上 Incomplete 的effectTag</span></span><br><span class="line">  <span class="title function_">throwException</span>(</span><br><span class="line">    root,</span><br><span class="line">    erroredWork.<span class="property">return</span>,</span><br><span class="line">    erroredWork,</span><br><span class="line">    thrownValue,</span><br><span class="line">    workInProgressRootRenderLanes,</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开始对错误节点执行completeWork阶段</span></span><br><span class="line">  <span class="title function_">completeUnitOfWork</span>(erroredWork);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>重点：从发生错误的节点往上找到错误边界，做记号，记号就是ShouldCapture 的 effectTag。</strong></p>
<h2 id="错误边界再次更新"><a href="#错误边界再次更新" class="headerlink" title="错误边界再次更新"></a>错误边界再次更新</h2><p>当这个错误节点进入completeUnitOfWork时，因为持有了<code>Incomplete</code>，所以不会进入正常的complete流程，而是会进入错误处理的逻辑。</p>
<p>错误处理逻辑做的事情：</p>
<ul>
<li>对出错节点执行<code>unwindWork</code>。</li>
<li>将出错节点的父节点（returnFiber）标记上<code>Incomplete</code>，目的是在父节点执行到completeUnitOfWork的时候，也能被执行unwindWork，进而验证它是否是错误边界。</li>
<li>清空出错节点父节点上的effect链。</li>
</ul>
<p>这里的重点是<code>unwindWork</code>会验证节点是否是错误边界，来看一下unwindWork的关键代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">unwindWork</span>(<span class="params">workInProgress: Fiber, renderLanes: Lanes</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (workInProgress.<span class="property">tag</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">ClassComponent</span>: &#123;</span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> effectTag = workInProgress.<span class="property">effectTag</span>;</span><br><span class="line">      <span class="keyword">if</span> (effectTag &amp; <span class="title class_">ShouldCapture</span>) &#123;</span><br><span class="line">        <span class="comment">// 删它上面的ShouldCapture，再打上DidCapture</span></span><br><span class="line">        workInProgress.<span class="property">effectTag</span> = (effectTag &amp; ~<span class="title class_">ShouldCapture</span>) | <span class="title class_">DidCapture</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> workInProgress;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>unwindWork</code>验证节点是错误边界的依据就是节点上是否有刚刚<code>throwException</code>的时候打上的ShouldCapture的effectTag。如果验证成功，最终会被return出去。return出去之后呢？会被赋值给workInProgress节点，我们往下看一下错误处理的整体逻辑：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((completedWork.<span class="property">effectTag</span> &amp; <span class="title class_">Incomplete</span>) === <span class="title class_">NoEffect</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正常流程</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 验证节点是否是错误边界</span></span><br><span class="line">  <span class="keyword">const</span> next = <span class="title function_">unwindWork</span>(completedWork, subtreeRenderLanes);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (next !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果找到了错误边界，删除与错误处理有关的effectTag，</span></span><br><span class="line">    <span class="comment">// 例如ShouldCapture、Incomplete，</span></span><br><span class="line">    <span class="comment">// 并将workInProgress指针指向next</span></span><br><span class="line">    next.<span class="property">effectTag</span> &amp;= <span class="title class_">HostEffectMask</span>;</span><br><span class="line">    workInProgress = next;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...省略了React性能分析相关的代码</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (returnFiber !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 将父Fiber的effect list清除，effectTag标记为Incomplete，</span></span><br><span class="line">    <span class="comment">// 便于它的父节点再completeWork的时候被unwindWork</span></span><br><span class="line">    returnFiber.<span class="property">firstEffect</span> = returnFiber.<span class="property">lastEffect</span> = <span class="literal">null</span>;</span><br><span class="line">    returnFiber.<span class="property">effectTag</span> |= <span class="title class_">Incomplete</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">// 继续向上completeWork的过程</span></span><br><span class="line">completedWork = returnFiber;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在我们要有个认知，一旦unwindWork识别当前的workInProgress节点为错误边界，那么现在的workInProgress节点就是这个错误边界。然后会删除掉与错误处理有关的effectTag，DidCapture会被保留下来。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (next !== <span class="literal">null</span>) &#123;</span><br><span class="line">  next.<span class="property">effectTag</span> &amp;= <span class="title class_">HostEffectMask</span>;</span><br><span class="line">  workInProgress = next;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>重点：将workInProgress节点指向错误边界，这样可以对错误边界重新走更新流程。</strong></p>
<p>这个时候workInProgress节点有值，并且跳出了completeUnitOfWork，那么继续最外层的工作循环：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">workLoopConcurrent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">while</span> (workInProgress !== <span class="literal">null</span> &amp;&amp; !<span class="title function_">shouldYield</span>()) &#123;</span><br><span class="line">    <span class="title function_">performUnitOfWork</span>(workInProgress);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，workInProgress节点，也就是错误边界，它会<strong>再被performUnitOfWork处理，然后进入beginWork、completeWork！</strong></p>
<p>也就是说它会被重新更新一次。为什么说再被更新呢？因为构建workInProgress树的时候，beginWork是从上往下的，当时workInProgress指针指向它的时候，它只执行了beginWork。此时子节点出错导致向上completeUnitOfWork的时候，发现了他是错误边界，workInProgress又指向了它，所以它会再次进行beginWork。不同的是，这次节点上持有了<br>DidCapture的effectTag。所以流程上是不一样的。</p>
<p>还记得<code>throwException</code>阶段入队错误边界更新队列的表示错误的update吗？它在此次beginWork调用processUpdateQueue的时候，会被处理。<br>这样保证了<code>getDerivedStateFromError</code>和<code>componentDidCatch</code>的调用，然后产生新的state，这个state表示这次错误的状态。</p>
<p>错误边界是类组件，在beginWork阶段会执行<code>finishClassComponent</code>，如果判断组件有DidCapture，会卸载掉它所有的子节点，然后重新渲染新的子节点，这些子节点有可能是经过错误处理渲染的备用UI。</p>
<p><em>示例代码来自React<a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/error-boundaries.html">错误边界介绍</a></em></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ErrorBoundary</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123; <span class="attr">hasError</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">getDerivedStateFromError</span>(<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 更新 state 使下一次渲染能够显示降级后的 UI</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">hasError</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">componentDidCatch</span>(<span class="params">error, errorInfo</span>) &#123;</span><br><span class="line">    <span class="comment">// 你同样可以将错误日志上报给服务器</span></span><br><span class="line">    <span class="title function_">logErrorToMyService</span>(error, errorInfo);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">hasError</span>) &#123;</span><br><span class="line">      <span class="comment">// 你可以自定义降级后的 UI 并渲染</span></span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Something went wrong.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">children</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于上述情况来说，一旦ErrorBoundary的子树中有某个节点发生了错误，组件中的<code>getDerivedStateFromError</code> 和 <code>componentDidCatch</code>就会被触发，<br>此时的备用UI就是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;<span class="title class_">Something</span> went wrong.&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<h2 id="流程梳理"><a href="#流程梳理" class="headerlink" title="流程梳理"></a>流程梳理</h2><p>上面的错误处理我们用图来梳理一下，假设<code>&lt;Example/&gt;</code>具有错误处理的能力。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1              App</span><br><span class="line">                |</span><br><span class="line">                |</span><br><span class="line">2           &lt;Example/&gt;</span><br><span class="line">              /</span><br><span class="line">             /</span><br><span class="line">3 ---&gt;   &lt;List/&gt;---&gt;span</span><br><span class="line">          /</span><br><span class="line">         /</span><br><span class="line">4       p ----&gt; &#x27;text&#x27;</span><br><span class="line">       /</span><br><span class="line">      /</span><br><span class="line">5    h1</span><br></pre></td></tr></table></figure>

<p>1.如果<code>&lt;List/&gt;</code>更新出错，那么首先<code>throwException</code>会给它打上Incomplete的effectTag，然后以它的父节点为起点向上找到可以处理错误的节点。</p>
<p>2.找到了<code>&lt;Example/&gt;</code>，它可以处理错误，给他打上ShouldCapture的effectTag（做记号），创建错误的update，将<code>getDerivedStateFromError</code>放入payload，<code>componentDidCatch</code>放入callback。<br>，入队<code>&lt;Example/&gt;</code>的updateQueue。</p>
<p>3.从<code>&lt;List/&gt;</code>开始直接<code>completeUnitOfWork</code>。由于它有Incomplete，所以会走<code>unwindWork</code>，然后给它的父节点<code>&lt;Example/&gt;</code>打上Incomplete，<code>unwindWork</code>发现它不是刚刚做记号的错误边界，<br>继续向上<code>completeUnitOfWork</code>。</p>
<p>4.<code>&lt;Example/&gt;</code>有Incomplete，进入<code>unwindWork</code>，而它恰恰是刚刚做过记号的错误边界节点，去掉ShouldCapture打上DidCapture，将workInProgress的指针指向<code>&lt;Example/&gt;</code></p>
<p>5.<code>&lt;Example/&gt;</code>重新进入beginWork处理updateQueue，调和子节点（卸载掉原有的子节点，渲染备用UI）。</p>
<p>我们可以看出来，React的错误边界的概念其实是对可以处理错误的组件重新进行更新。错误边界只能捕获它子树的错误，而不能捕获到它自己的错误，自己的错误要靠它上面的错误边界来捕获。我想这是由于出错的组件已经无法再渲染出它的子树，也就意味着它不能渲染出备用UI，所以即使它捕获到了自己的错误也于事无补。</p>
<p>这一点在<code>throwException</code>函数中有体现，是从它的父节点开始向上找错误边界：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从当前节点的父节点开始向上找</span></span><br><span class="line"><span class="keyword">let</span> workInProgress = returnFiber;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="keyword">while</span> (workInProgress !== <span class="literal">null</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>回到completeWork，它在整体的错误处理中做的事情就是对错误边界内的节点进行处理：</p>
<ul>
<li>检查当前节点是否是错误边界，是的话将workInProgress指针指向它，便于它再次走一遍更新。</li>
<li>置空节点上的effectList。</li>
</ul>
<p>以上我们只是分析了一般场景下的错误处理，实际上在任务挂起（Suspense）时，也会走错误处理的逻辑，因为此时throw的错误值是个thenable对象，具体会在分析suspense时详细解释。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>workInProgress节点的completeWork阶段主要做的事情再来回顾一下：</p>
<ul>
<li>真实DOM节点的创建以及挂载</li>
<li>DOM属性的处理</li>
<li>effectList的收集</li>
<li>错误处理</li>
</ul>
<p>虽然用了不少的篇幅去讲错误处理，但是仍然需要重点关注正常节点的处理过程。completeWork阶段处在beginWork之后，commit之前，起到的是一个承上启下的作用。它接收到的是经过diff后的fiber节点，然后他自己要将DOM节点和effectList都准备好。因为commit阶段是不能被打断的，所以充分准备有利于commit阶段做更少的工作。</p>
<p>一旦workInProgress树的所有节点都完成complete，则说明workInProgress树已经构建完成，所有的更新工作已经做完，接下来这棵树会进入commit阶段，从下一篇文章开始，我们会分析commit阶段的各个过程。</p>
<p>欢迎扫码关注公众号，发现更多技术文章</p>
<p><img src="https://neroht.com/qrcode-small.jpg"></p>

            <div class="clearfix"></div>
            <hr class="nogutter">
        </div>
        <nav class="m-pagination col-md-8 col-md-offset-2 col-sm-24" role="pagination">
    
    <a class="pull-left" href="/2-React_Source/%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/DOM%E5%85%83%E7%B4%A0%E7%9A%84owner%E5%B1%9E%E6%80%A7/" style="float: left;">
        ← 
    </a>
    
    
    <a class="pull-right" href="/2-React_Source/render%E9%98%B6%E6%AE%B5/beginWork%E9%98%B6%E6%AE%B5/%E5%A4%84%E7%90%86%E6%9B%B4%E6%96%B0/">
         →
    </a>
    
</nav>

        <div class="col-md-8 col-md-offset-2 col-sm-24"><script type="text/javascript">
  /**
   * 搜狐畅言
   */

  /*
  document.write('<div id="SOHUCS" sid="' + window.location.pathname.slice(1) + '" ></div>');

  window.onload = function () {
    (function () {
      var appid = 'cytXXXX';
      var conf = 'prod_xxxxxxxxxxxxxxxxx';
      var width = window.innerWidth || document.documentElement.clientWidth;
      var loadJs = function (d, a, id) {
        var c = document.getElementsByTagName("head")[0] || document.head || document.documentElement;
        var b = document.createElement("script");
        b.setAttribute("type", "text/javascript");
        b.setAttribute("charset", "UTF-8");
        b.setAttribute("src", d);
        if (id) {
          b.setAttribute("id", id);
        }
        if (typeof a === "function") {
          if (window.attachEvent) {
            b.onreadystatechange = function () {
              var e = b.readyState;
              if (e === "loaded" || e === "complete") {
                b.onreadystatechange = null;
                a()
              }
            }
          } else {
            b.onload = a
          }
        }
        c.appendChild(b)
      };

      loadJs("https://changyan.sohu.com/upload/changyan.js", function () {
        window.changyan.api.config({
          appid: appid,
          conf: conf
        })
      });
    })();
  }
  */

</script>
</div>
    </div>
</section>


      
<!-- ============================ Footer =========================== -->

<footer>
    <div class="container">
            <div class="copy">
                <p>
                    &copy; 2014<script>new Date().getFullYear()>2010&&document.write("-"+new Date().getFullYear());</script>, Content By 盛祥玉. All Rights Reserved.
                </p>
                <p>Theme By <a target="_blank" rel="noopener" href="//go.kieran.top" style="color: #767D84">Kieran</a></p>
            </div>
            <div class="social">
                <ul>
                    
                    <li><a href="https://github.com/Yxgm" title="Github" target="_blank"><i class="icon-github"></i></a>&nbsp;</li>
                    
                    
                    
                    
                    
                </ul>
            </div>
            <div class="clearfix"> </div>
        </div>
</footer>

<!-- ============================ END Footer =========================== -->
      <!-- Load our scripts -->
<!-- Resizable 'on-demand' full-height hero -->
<script type="text/javascript">
    var resizeHero = function () {
        var hero = $(".cover,.heightblock"),
            window1 = $(window);
        hero.css({
            "height": window1.height()
        });
    };

    resizeHero();

    $(window).resize(function () {
        resizeHero();
    });
</script>
<script src="/js/plugins.min.js"></script><!-- Bootstrap core and concatenated plugins always load here -->
<script src="/js/scripts.js"></script><!-- Theme scripts -->


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$('#intro').find('img').each(function(){
  var alt = this.alt;

  if (alt){
    $(this).after('<span class="caption" style="display:none">' + alt + '</span>');
  }

  $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="gallery" />');
});
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



      
</body>
</html>
